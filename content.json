{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"飞机大战1","slug":"飞机大战1","date":"2021-03-20T01:39:03.000Z","updated":"2021-03-20T01:51:01.495Z","comments":true,"path":"2021/03/20/飞机大战1/","link":"","permalink":"http://example.com/2021/03/20/%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%981/","excerpt":"","text":"文章目录（一）飞机大战演示&amp;游戏基本设定介绍&amp;环境搭建1️⃣飞机大战演示 2️⃣游戏的基本设定2️⃣游戏的基本设定❤敌方共有大中小3款飞机，分为高中低三种速度； ❤子弹的射程并非全屏，而大概是屏幕长度的80%； ❤消灭小飞机需要 1 发子弹，中飞机需要 8 发，大飞机需要 20 发子弹； ❤每消灭一架小飞机得1000分，中飞机6000分，大飞机10000分； ❤每隔30秒有一个随机的道具补给，分为两种道具，全屏炸弹和双倍子弹； ❤全屏炸弹最多只能存放 3 枚，双倍子弹可以维持 18 秒钟的效果； ❤游戏将根据分数来逐步提高难度，难度的提高表现为 飞机数量的增多以及速度的加快； ❤为中飞机和大飞机增加了血槽的显示，这样我们可以直观的知道敌机快被消灭了没有； ❤我方有三次机会，每次被敌人消灭，新诞生的飞机会有 3 秒钟的安全期； ❤游戏结束后会显示历史最高分数。 3️⃣准备游戏的素材，搭建环境（二）开工！先实现main模块游戏的背景和背景音乐 ❤images文件夹里边就是各种资源图片 ❤sound文件夹里边就是游戏需要的背景声音以及各种音效 ❤bullet.py，里边就是实现子弹的代码，子弹有两种，一种是一次打一发，一种是一次可以打2发 ❤enemy.py，里边就是实现敌机生成的代码，有三种敌机，小的，中的，还有大的，他们都有不同的属性，所以就分别定义在这个模块里 ❤main.py，这个就是主程序，主模块了 ❤myplane.py，就是生成玩家的飞机 ❤record.txt，就是用于保存历史最高分 ❤supply.py, 里边是实现补给的代码，就是每隔30秒就提供一次补给。提供什么类型的补给是随机的，有屏幕炸弹，当前屏幕上的敌机都会被炸掉，全屏炸弹总共可以存储3个，也就是说你有3个了，再多加一个没用，还有另一种补给就是双枪，可以持续18秒钟 （二）开工！先实现main模块游戏的背景和背景音乐首先先来完成main模块里边游戏背景和背景音乐的，main.py源代码👇 import pygameimport sysimport tracebackfrom pygame.locals import * pygame.init()pygame.mixer.init() bg_size = width,height = 480,700screen = pygame.display.set_mode(bg_size)pygame.display.set_caption(“飞机大战 – Monster ZF”) background = pygame.image.load(“images/background.png”).convert() 载入游戏音乐pygame.mixer.music.load(“sound/game_music.ogg”)pygame.mixer.music.set_volume(0.2)bullet_sound = pygame.mixer.Sound(“sound/bullet.wav”)bullet_sound.set_volume(0.2)bomb_sound = pygame.mixer.Sound(“sound/use_bomb.wav”)bomb_sound.set_volume(0.2)supply_sound = pygame.mixer.Sound(“sound/supply.wav”)supply_sound.set_volume(0.2)get_bomb_sound = pygame.mixer.Sound(“sound/get_bomb.wav”)get_bomb_sound.set_volume(0.2)get_bullet_sound = pygame.mixer.Sound(“sound/get_bullet.wav”)get_bullet_sound.set_volume(0.2)upgrade_sound = pygame.mixer.Sound(“sound/upgrade.wav”)upgrade_sound.set_volume(0.2)enemy3_fly_sound = pygame.mixer.Sound(“sound/enemy3_flying.wav”)enemy3_fly_sound.set_volume(0.2)enemy1_down_sound = pygame.mixer.Sound(“sound/enemy1_down.wav”)enemy1_down_sound.set_volume(0.1)enemy2_down_sound = pygame.mixer.Sound(“sound/enemy2_down.wav”)enemy2_down_sound.set_volume(0.2)enemy3_down_sound = pygame.mixer.Sound(“sound/enemy3_down.wav”)enemy3_down_sound.set_volume(0.5)me_down_sound = pygame.mixer.Sound(“sound/me_down.wav”)me_down_sound.set_volume(0.2) def main(): pygame.mixer.music.play(-1) clock = pygame.time.Clock() running = True while running: for event in pygame.event.get(): if event.type == QUIT: pygame.quit() sys.exit() screen.blit(background,(0,0)) pygame.display.flip() clock.tick(60) if name == “main“: try: main() except SystemExit: pass except: traceback.print_exc() pygame.quit() input() 代码解析: 首先导入pygame就不用说了，import sys 后边退出程序程序会用到这个模块的exit() 方法让程序正常退出，接着import traceback 是为了让游戏更好友好地退出以及捕获异常等等，from pygame.locals import * 这个就是把pygame当地的常量都导入，比如pygame.QUIT，等一些事件，就不用加pygame这个前缀，直接写事件的名字的就可以了。 接着 pygame.init() 初始化pygame，pygame.mixer.init() 初始化混音器 接着 bg_size = width,height = 480,700 游戏背景的尺寸，这个完全是根据background.png 这张背景图片来设置的 接着screen = pygame.display.set_mode(bg_size) 创建这个尺寸的窗口大小，接着这个就是 pygame.display.set_caption(“飞机大战 – Monster ZF”) 设置窗口的标题咯 接着background = pygame.image.load(“images/background.png”).convert() 把背景图片给加载进来，因为这个是不透明的，直接用convert方法转化就好了，然后就获得了背景图片的Surface对象 接着就是把游戏中需要用到的背景音乐和各种音效全部载入，背景音乐用的是music模块下的 load()方法 然后音效就是用 mixer 模块里的Sound方法，set_volume(0.2) 这个方法是用来设置背景音乐和音效的音量的 接着def main(): 就是来个main函数表示主模块的主函数，进入主函数就可以先来 播放 游戏的背景音乐 pygame.mixer.music.play(-1) 其中参数-1表示无限循环播放。 接着 running = True ，之前也说了，这个变量是用来控制游戏结束的，但是这个变量在这里似乎作用不大，因为这里会有其他的方式来暂停和退出游戏，接着就可以进入循环，while running: 那么进入循环后for event in pygame.event.get(): 就是来迭代遍历事件列表，因为之前也说过了，pygame会把游戏中产生的所有事件，包括鼠标移动，键盘事件等等都放在一个事件列表中，我们只需要遍历从里边检测就行了，检测到什么事件就相应写上响应这个事件的具体代码 接着 screen.blit(background,(0,0)) 就是把背景图片在内存中画出来，第一个参数是图片的Surface对象，就是背景图片前面已经加载好了，第二个参数是一个元组，这里表示从(0,0)开始画起，即从左上角开始画起，窗口的默认(0,0)坐标就是左上角 接着pygame.display.flip() 就是画完之后，把图片翻转出来，也就是把图片从内存中显示到显示器上 然后clock = pygame.time.Clock() 初始化一下Clock对象，下面用于控制游戏的速度 clock.tick(60) 这里设置为最大60帧 最后这里except SystemExit: 如果是正常的退出，他就抛出**SystemExit:**的异常，直接不管他pass就可以了，如果说是其他异常的话，就报告一下，traceback.print_exc() 这主要就是让我们在双击这个python源代码文件执行的时候，不会说如果出错了，就一闪而过，我们要让他停留，打印出相关的错误，input() 就是起到一个停留的作用，接受用户的输入，然后才可以走 运行效果:👇","categories":[],"tags":[]},{"title":"深入浅出数据分析（心得）","slug":"深入浅出数据分析（心得）","date":"2021-03-20T01:36:38.000Z","updated":"2021-03-20T01:37:18.583Z","comments":true,"path":"2021/03/20/深入浅出数据分析（心得）/","link":"","permalink":"http://example.com/2021/03/20/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%88%E5%BF%83%E5%BE%97%EF%BC%89/","excerpt":"","text":"1.有些人把问题视为机会，而向客户指出如何发现机会的数据分析师则能让客户赢得竞争优势。 思考:如何发现机会呢，我想不单单是盯着一堆数据表看着就能得出这样的结果，要有对整个行业的需求和趋势进行很好的敏锐察觉。要想有这样的行为，那么我们的思维逻辑中就不应该是排斥数据的人，应该喜欢搜罗数据。 2.将问题和数据分解为更小的组块，合适的方法就是比较对象，分解汇总数据。还有就是总结一下客户(绝对的需求点＋确信) 3.在做数据分析时，你是在用自己的信用为自己的结论打赌。 思考:这是很重要的。你的假设来自于自己的三观，平日的生活积累，这些点点滴滴促使你建立了一个分析模型＋你自己对数据的初期评估。但是，万一你的初期理解和分析，就和客户的初心背道而驰呢?你给出的结论和方法可以满足你自己的看法理论，但是不一定是客户所需要的最优解。所以我们应该做的就是，将自己的设想和判断让客户理解＋鼓励客户以数据为基础做出明智的决策。 审视数据，通过客户把事情弄明白，客户明确的观点+自己的数据理解相比较，再提出决策。 往往有一个问题:万一客户的确信的观点出了问题，那么作为数据分析师，就得全部重头再来，因为解释模型的数据理论都是错误的。 4.不同的心智模型对应了不同的统计模型。 使用心智模型:需要了解自己和客户不知道不了解的东西，这些东西可能是导致不同的确信观点的重要因素。也许知道了某些东西，确信观点，分析的基石就会变化。 5.千万要保存原始数据(太真实了) 6.回顾问题，提炼模型，基于新模型观察外界，这是分析师的工作规律。一旦得到的数据有违背假设，回头重新思考。 思考:其实这个就和做research中如果得到的结果提升有了异常，我们回头去检查模型的问题是一样的道理。 7.比较越多，分析结果越正确。观察研究法无处不在! 8.知识点:混杂因素——研究对象的个人差异。 思考:算是不同状态的同一性质量。我们在做预期分析的时候需要有控制变量进行实验，与此同时，精心选择分组，避免混杂因素。 最好的方法:随机选择对象。这样会使得混杂因素在两个实验中的影响相同，从而达到消去的效果。 9.在做一个数据分析前，需要找到可控变量和不可控变量。决策可以控制的，避免或者弱化不可控的，这样会让分析和决策更有意义。 公式:p=c1x1 ＋c2x2…..cnxn(c为约束条件，x为决策变量) 10.一切模型都是错误的，但其中一些是有用的. 思考:基于实际变化进行不断的假设改变 11.数据图形化的根本在于正确比较。 12.有时候将分析报告中的”可能” “大概率”什么的变成数字分析，会更加准确且理性 13.分析存在于现实与模型之间的预期差距，是数据分析的一个重要内容。 14.那么努力工作不是为了锻炼身体。 15.，假设检验+预测 =数据分析 16.你可以快速地生成回归方程，但是不代表这个回归线的预测就有用。 17.机会误差=实际结果与模型预测结果之间的偏差。指出预测的范围比单单指出一个数字有用得多。 这些和机器学习里面都差不多 18.将数据分割为多个组，分别进行模型分析，有助于管理误差分析。 19.花在数据整理上的时间要多过数据分析上的时间。 作为数据分析的入门书，还是蛮不错的哦","categories":[],"tags":[]},{"title":"pPython数据分析（语法）","slug":"pPython数据分析（语法）","date":"2021-03-20T01:34:54.000Z","updated":"2021-03-20T01:35:56.510Z","comments":true,"path":"2021/03/20/pPython数据分析（语法）/","link":"","permalink":"http://example.com/2021/03/20/pPython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%88%E8%AF%AD%E6%B3%95%EF%BC%89/","excerpt":"","text":"一、数据 结构化数据： 1.多维数组——矩阵 2.表格型数据（关系型数据库中的数据） 3.通过关键列相连接的表 4.间隔平均或者不平均的时间序列 二、关于iPython 三、Numpy学习 numpy是高性能科学计算和数据分析的基础包。它本身没有太多高级分析的功能，重点在于理解Numpy数组以及面向数组的计算。 1.Numpy.ndarray ndarray中的元素必须都是相同类型，每个数组都有一个shape（一个表示各维度大小的元组,也就是几行几列）+一个dtype（说明数组类型的对象，数字啊还是字母什么的） 列表+np.array（列表） = 数组 嵌套列表（等长）+np.array（列表） = 多维数组 特殊的数组：np.array.zeros(x,y) 产生x行y列的全为0的数组 np.array.ones（x，y）全为1 np.arrary.empty(x，y）产生x行y列的随机数的数组 np.arrange（）range的数组版 ps：Numpy中的数组的dtype基本上是浮点数、复数、整数、布尔值….如果需要转换type的话，用np.array.astype（） 2.数组与标量之间的运算 数组与标量之间的运算很简单，是每一个数组里面的元素都和标量运算一遍，再返回到原有的索引位置。一维数组长得和列表差不多，很多功能也是很相似的。主要的区别在于：数组切片是原数组的视图，修改了元素之后，数据不会被赋值，而是直接反应到原数组上。（如果想要有副本，用copy（）函数） 需要赋值就直接赋值即可，直接会被修改。 3.矩阵中的元素索引 在二维数组中，单一索引代表了是一维数组。要用元素的话索引得是[x][y[,表明寻求x行y列的那个元素。同理，一个索引降一维度，如果是n为数组，需要有[n][b][a]….[1]，n个索引才能达到最后的单独的一个元素。 高阶维度的切片是沿着axis来切的。具体可以查阅别的blog. 4.bool型索引 numpy.random.randn（）可生成随机数据 给出一个索引，满足索引条件的都会被打印出来。bool型索引可以和切片，整数序列混合使用。data[索引条件，切片]（切片不写默认全data），有了这个找一些数据或者调整一些数据就会变得很简单。 5.数组转置和轴对换 T属性（转置）np.arrange.T() np.dot函数计算转置数组和原数组的内积 对于高维数组，需要得到转置的轴才能进行转置，用transpose方法。transpose进行的操作其实是将各个维度重置。 还有一种swapaxes方法：接受一对轴编号进行变换。 6.通用函数（nfunc） nfunc是针对ndarray里元素数据执行的函数。算是一般函数的矢量版。 有一元nfunc，针对一组数组。二元nfunc，针对二组数组。 7.利用数组处理数据 用数组表达式代替循环的计算方法，称为矢量化。 单纯的数据计算还是很普通的。学到了np.meshgrid（）这样的方法。 8.将逻辑表述转化为数组运算 numpy.where函数是三元表达式（x if condition else y）的矢量化版本。 在数据分析工作中，常常用where来从数组A生成新的数组B。 numpy.where(cond,x,y)其中x，y不一定是数组，单纯的数据也行。where方法也可以进行逻辑上的嵌套。 数学和统计方法 sum,mean，std，var，min，max，argmin，argmax，cumsum，cumprod 这些都是需要考虑axis（轴方向的）。 用于bool型数组的方法 1.sum对bool型数组里面的true和false个数计数（True为1，False为0） 2.any 和all 唯一化以及其他集合逻辑 np.unique（）返回数组里面的唯一的元素（滤去重复的） np.in1d（x，12,3）看x中的数组元素是否有12,3. 9.用于数组以二进制输出输入 针对数组：一般用np.save（）和np.load（） 针对文本文件：np.loadtxt（）和np.savetxt（） 10.随机数生成 np.random（）函数 四、pandas入门 1.pandas的数据结构介绍 Series和Dataframe Series是由一组Numpy数组+各个数据的索引标签组成的类似于一维数组的对象。表现形式为左列为索引，右列为数据。 Series.values获得数组，Series.index获得索引。 Numpy数组的正常算法（加减乘除，条件过滤），在pandas中都会保留索引和值之间的连接。 自然有时候也可以把Series看做一种字典。索引可以找到对应的数组。索引也可以通过直接赋值的方式进行修改。 如有已生成的字典A，可以用个B = Series（A）来将字典转换成Series. 在数据丢失的情况下，我们会发现Series出现了NaN（表示数据缺失）。 对应的方法：pd.isnull（），pd.notnull（），Series.isnull（） Series的突出之处：在算数运算中它可以自动对齐不同索引的数据。（就是虽然不对齐，但是你知道应该要对齐的那些数据，很自动，很方便。） DataFrame是一种表格型数据结构。DataFrame既**有行索引也有列索引,**且面向行和面向列的操作基本上平衡。 有很多种构建DataFrame的方法： 1.传入几个等长的数组（列表）作为一个整体的data，再用DataFrame（data）即可。和Series一样，DataFrame会自动添加索引。 类似于字典取需要的数据的方法：DataFrame[“A”](A为其中的一个列），这样我们就可以得到类似于一个Series的数据，左边是索引，右边是DataFrame中的A列。同样可以进行类似的行操作DataFrame[S](S为某个行的标签）。 在DataFrame中赋值（主要几种） 1可以直接赋值 2也可以用一串数组赋值献给某个列（前提是长度要匹配）。 3也可以用Series进行精确赋值(先建立一个新列A，再创建一个新SeriesB（有数组，有索引），再用DataFrame[‘A’] = B) 在DataFrame中删除多余的列——del[“列名”] 4 将嵌套字典（Series数组也差不多）赋给DataFrame.默认将外层字典的键作为了列名，内层字典的键作为了行索引（如果显示决定了索引，就按显示的来）。 ps：如果设置了DataFrame中index和column中的name属性（DataFrame.index.name()） 就会显示出来的。DataFrame.values（）的话，就会返回二维ndarray形式。 关于索引对象（略微知道即可） pandas的索引对象负责管理轴标签和其他元数据（如轴名称），构建Series和DataFrame时，数据标签都会转成index. index对象是不可修改的。 2.基本功能 重新索引： Series.reindex（），重新在括号里面写索引index即可。 索引也有两种method:顺序填充，顺序填充ffill和倒序填充bfill. example:obj.reindex（[“1”,”2”,”3”,”4”,“5”],method = ffill） 在DataFrame中，reindex可以修改整个行或者整个列。 如果只传了一个序列，就默认是修改行的。如果要修改列的话，需要多加一个column关键字赋值。（A = 序列 ，reindex（column = A）） 当然，可以同时对行和列一起进行index的修改。 丢弃指定轴上的数： 在Series中，用Series.drop（index）函数，填哪些index，那一行或者一列就没有了。 在DataFrame中，可以删去任意轴上的index值。（在二维中，axis=0为列，axis=1为行） 关于Series的索引切片，方法类似于Numpy数组的索引，但是 1.索引出来的结果不是整数，会给出series的结果样子 2.切片是首尾的数字都包含的，而不是末尾-1 在DataFrame中，方式也类似。因为DataFrame为二维的表格，会显得更加有逻辑性，可以通过切片data[0:2]或者bool型条件进行选择（类似于data[data[“Three”]&gt;5]） DataFrame中有独特的索引方法(选取原DataFrame中的行列子集）： data.ix[[“x’，“c”],[a,s,d]]前者为行名，后者为列名。（如果是单个行或列，就不需要加括号了）！我实名证明！Data.ix[]是真的好用！ 算术运算和数据对齐： Pandas中的数据相加，自动取并集(能正常计算的就继续计算，不能的就返回一个NaN) Series就是列并起来，DataFrame就是行和列同时搞定合并。 如果不想返回一个NaN，就在合并的时候用add方法并且多加一个参数fill_value = X,这样就会返回X，而不是NaN了。Data1.add(Data2,fill_value = X) 下面讲一下关于DataFrame和 Series之间的运算： 将series对标DataFrame中的某一行，就可以进行计算。会沿着某一行（之前用ix设定的行）一行行往下传播。 函数应用and映射： 1.Numpy中的nfunc方法可以应用于操作Pandas对象。 2.将函数应用到由各列或者各行组成的一维数组上。用pd.apply(f),f可以为自定义函数。（不太需要用，因为在设计的时候DataFrame的方法很多都可以直接用了 如sum mean） 顺序和排名： Series——X.sort_index()or X.order（） DataFrame——X.sort_index(axis)#需要多加一个轴，便于排名，有单个/多个列需要给指定的列排序的话X.sort_index(by=”列名”or[“列名1”,”列名2”]) 需要降序的话，就多加一个参数 ascending = False（这里不是按大小排序，而是按照列标签） Data.rank（）用于排名 带有重复值的轴索引： 某个索引对应多个值，返回一个Series.某个索引对应单指，返回对应的值。 汇总和计算描述统计： 1.用于在Series中提取单值（sum、mean等） 2.用于在DataFrame中提取一个Series。（多了需要考虑行列的方向轴axis） 常见的一些方法： data.idmax() 返回某个轴的最大值索引或最小值索引。 data.cumsum（）一行行或者一列列累加 data.describe（）一次性返回很多数据。（针对Series和DataFrame中的Series来返回汇总数据） 相关系数与协方差： data.A.corr（data.B）表示data中A列和B列之间的相关系数。 data.A.cov(data.B)表示data中A列和B列之间的协方差系数。 如果：data为Series，那就返回的是数据结果。如果是DataFrame，data.corr（）返回的是完整的相关系数，data.cov()返回的是完全的协方差矩阵。 具体在DataFrame中某一行或列与其他Series或者其他DataFrame，需要用data.corrrwith（） 传入一个Series会返回一个相关系数值Series. 传入一个DataFrame则会按名字返回配对的相关系数。 还有一个很高级的pandas方法：data.value——count（在Series和DataFrame中都可以用，返回出现频率，按计数值降序排列） 处理缺失数据： Pandas中有专门的符号表示：NaN（表示浮点和非浮点数组中的缺失数据） 如何过滤掉缺失数据：Series.dropna() 返回一个仅含非空数据和索引的Series 对于DataFrame，dropna（）默认将所有含有NaN的行列都删去。（有点错杀的感觉） 添加参数 how = ‘all’，这样将一列（行）全部都是NaN才删去 填充缺失数据： 1.用data.fillna（）不加参数默认将所有的NaN填入（）中的数据。 2.字典方法 data.fillna（{列1：数据1；列2,：数据2}） 层次化索引： 层次化索引是一种高级功能，使能在一条轴上拥有多个索引级别。（以低维度形式处理高纬度数据） 在DataFrame中，层次化索引很重要：通过unstack（）和stack（）方法，将一个拥有多重索引的轴的Series可以变成一个DataFrame.如图： 重排分级顺序： 用data.swaplevel（“key1”，“key2”）接受两个不同级别编号或者名称，并返回一个互换级别的对象。、 用data.sortlevel（axis）来进行顺序排序（按大小） 在DataFrame中，data.set_index()可以将一个列或者多个列转变成行索引，并创建一个新的DataFrame. data.resetindex()是data.set_index的逆变化. Numpy高级用法 ndarray对象的内部机理： 组成： 指向数组的指针+dtype+一个表示数组shape的元组+一个跨度元组（为了前进到当前维度的下一个元素所需要跨过的字节数） 高级数组操作： 1.数组重塑 reshape方法：（一般由低维度数组转到高纬度数组）array = A，A.reshape（x，y）x为外维，y为内维。y=-1是一种特殊表示，表示内维的数据个数，由外围和数组的总数据个数决定（比如总数据有20，外维为4，那么内维就为20/4=5） reshape的逆方法： 1.raveling（扁平化）表现形式为Data.ravel（）——将高纬度数组转到低纬度数组。 2.flatten方法 Data.flatten（）类似于ravel，但是不同在于返回的是副本。 原理：数组排列的顺序方式：C和Fortran顺序。 C顺序（行优先）：先处理高维度的axis F顺序（列优先）：先处理低维度的axis 2.数组的合并与拆分 numpy.concatenate(arr1，arr2，axis)用来合并数组（可以从不同的方向进行合并） 别的方式：numpy.vstack((arr1，arr2))按列合并 numpy.hstack((arr1,arr2))按行合并 方法split(ary, indices_or_sections, axis=0) :把一个数组从左到右按顺序切分 参数： ary:要切分的数组 indices_or_sections:如果是一个整数，就用该数平均切分，如果是一个数组，为沿轴切分的位置（左闭右开） 比如原来的数组是0到9，按数组[1:3]切分： 就会得到[[0],[1,2,],[3,4,5,6,7,8,9]] 3.元素的重复操作：tile和repeat arr.repeat有几种用法：1.arr.repeat(num) 将原本arr中的元素重复num遍 2.arr.repeat（[num1,num2,num3…]）针对不同元素重复不同的次数 ps：最好设置axis。 arr.title() 沿着指定axis堆叠副本（类似于铺瓷砖） 广播：（不同形状的数组之间的算数运算方式） 1.数组和数字之间的运算，将运算到数组内的每一个元素中. 如果两个数组的最末尾开始算起的维度的轴长度相符或其中一方长度为1，那么我们认为这两个数组是兼容的，可以进行广播。 如果是高维的数组，可以广播的条件就是：将低维度的数组需要沿某个轴的方向广播的那个轴，置1.看图： 对于低维度的数组，如何插入那个为1的新axis： arr[:,np.newaxis,:]（全切片+newaxis方法） 把newaxis放在前面的时候 以前的shape是5，现在变成了1×5，也就是前面的维数发生了变化，后面的维数发生了变化 而把newaxis放后面的时候，输出的新数组的shape就是5×1，也就是后面增加了一个维数 所以，newaxis放在第几个位置，就会在shape里面看到相应的位置增加了一个维数。如果是前后都要“：”，那就是创建一个新的axis. Ufunc高级应用： Numpy的二元nfunc有用于特定矢量化运算的特殊方法。 np.add.reduce() 对数组中的各个元素进行求和。 np.add.accumulate（） 产生一个和原数组相同大小的中间累计值的数组。 还有一种方法可以增加维度，不用用newaxis：np.subtract.outer（X，Y）输出的结果维度是X和Y的维度之和。（可以用此升维） 自定义nfunc： 函数向量化的几种方法： 1.np.frompyfunc（func,func中的参数个数，需要返回的参数格个数）此法需要先定义一个func。 2.numpy.vectorize（func） 在有序数组中查找元素： numpy.searchsorted（可仔细学习） Numpy的Matrix类 Numpy为了减少繁琐的矩阵运算代码，直接提供了Matrix类：单列或单行会以二维形式返回，使用*符号直接就是矩阵乘法。（ps：没有太多的线性代数运算就可以不太用这个） 12Xm = np.matrix（x）ym= Xm[:,0]#返回的就是二维的形式 Matrix的特殊属性：matrix.I（返回矩阵的逆矩阵） 关于matrix类和正常ndarray的转换：Xm = np.matrix（x） Ym = np.assarray（xm） 高级数组的输出输入 Numpy实现了一个对象：memmap。这个可以将大文件分成小段进行读写，可以用于ndarray的都可以实现在memmap. mmap = np.memmap（“name”，“type”，“mode”，“shape”）就可创建一个新的mmap了. 其他关于内存映像的没有深入研究。 关于Numpy的性能建议： 1.将python循环和条件循环尽量转变为数组运算和bool数组运算。 2.尽量使用广播 3.避免复制数据，尽量用数据视图（切片） 4.利用ufunc的各种方法。 Matplotlib入门（绘图和可视化） 默认import matplotlib.pyplot as plt Figure和Subplot 用plt.figure()可创建一个新的figure对象，add_subplot可创建子图 可以通过plt.subplot_adjust()来调整subplot之间的间距。 还有一些可以调标签，自定义标签。 通过label参数可以增加图例。ax.legend（loc = best）一般都用这个来决定label的位置。 在Matplotlib中绘制图像： pyplot里面有很多图类型库，直接调用＋参数就可。 Pandas绘图 pandas绘图有一个很好的地方就是，它的本来读取的数据就已经很有格式化了。有行有列，这样再加上已经造好的matplotlib轮子，绘图会变得很简单很简单。 大体分为两种 Series和DataFrame绘图。 Series的索引对象会自动传到Matplotlib，作为图像的X轴。 DataFrame的plot会自动给每一列数据绘制一条线。 绘图中不加参数，默认为折线图。需要绘制别的图就要加不同的参数： 1.柱状图，plot（kind = ‘bar’） 2.密度分布图，plot（kind = ‘kde’） 关于散状的scatter图，pandas有自带的pd.scatter_martrix() 举个例子：pd.scatter_matrix(data,diagonal =‘kde’，color =‘k’，alpha = 0.3） 处理数据高级运用： 1.合并数据集 数据集的合并或连接运算是通过一个或多个键将行连接起来的。 pandas的merge函数：（下面默认data都是创建好的DataFrame格式） pd.merge（data1，data2）（没有指定的话，会自动将重叠的列名当做键进行连接，比如共享一个key列） 合并的方式有很多种，默认为 inner（取数据之间的交集）还有别的：outer（并集），left、right 合并的数据有单对多，多（一个键对n个值）对多（同样的键对m个值），单对多就是排出 ，多对多就是排出 merge函数中有个参数选项suffixes（用于指定附加重叠列名上的字符串（类似于改名吧）） 之前都是将列名作为键进行Data之间的连接，下面我们将索引变成连接的对象： 1.一般的数据索引对象（无层次化）（left_index=*True *或者right_index = True ） 2.层次化的索引对象（关于层次化索引已经在Pandas入门中介绍）：好像方法同上（后期具体分析哈） DataFrame中的join方法可以很方便的通过索引来连接不同的数据。例：data.join（data2，how =‘outer’） 轴向合并：Pandas之concat函数 pd.concat（data1，data2，….）可以用来合并没有重复索引值的数据Series，默认是在axis= 0.具体的方法看官方文档。 重塑和轴向旋转 1.重塑层次化索引：pd.stack（）将数据的列变为行 pd.unstack（）将数据的行变为列 2.移除重复数据：Series.drop_duplicates(默认全部列，可单独筛选[‘列1’,’列2’]) 重命名轴索引： 1.data.index.map()(在括号里面可以直接修改轴的内容） 2.创建数据集的转换版——data.rename（） 1.可以直接用index，column直接赋值给dataFrame 2.可以利用字典的格式，键为原本的某个index，值为新的index，进行赋值。 离散化和元面划分： pd.cut(A,B)A为目标分组的类别，B为目标被分组的数据，返回的是一个二维数组（数组由每个数据所在的分组构成）+含有以目标分组为名的label属性。默认分组为闭区间（元面边界），如果右边需要开区间，添加参数 right = False） ps：如果cut传入的是面元数量，会根据数据的最小值和最大值进行面元均分。 qcut和cut类似，不同之处在于他的元面内数据个数相同。（这两个函数很重要，用于分割数据，使数据离散化） 排列和随机采样： 1.numpy.random.permutation（）只是将dataFrame或Series中一列数据进行重新排序，具体的顺序应自己给出。np.random.permutation(5)——对于前五列随机排序 一个选取子集的例子：df.take（np.random.permutation(len(df)[:3]) 计算指标/哑变量（用于机器学习、数学建模） 将分类变量转变为指标矩阵：如果有个DataFrame一列有7个不同的值，可派生出一个k列矩阵（值全为1或0）pd.get_dummies() 一个统计应用的tip：结合get_dummies和pd.cut等离散化函数。 数据聚合和分组运算 主要是用于对数据集进行分组，并对各个数据集进行某种func运算。 pandas之GroupBy技术 分组运算的过程：split—apply—combine df.[‘data1’].groupby[“key”]——获取data1中key的所在的列的数据（分组键），并返回一个GroupBy数据。然后可以根据GroupBy数据进行各种运算。 分组键有以下几种： 1.列表与数组，长度与待分组的数据长度相等 2.表示DataFrame中某个列名的值 3.字典或Series，给出值与分组名的关系 4.函数 也可以根据索引级别（多个索引的情况下）进行聚合，通过关键字 level = ‘index名’ df.groupby[sadasd].size() 返回一个含有分组大小的Series. 数据聚合： 定义：能够从数组产生标量值的数据转换过程。（比如mean，sum，count等最基本的方法） 对于Series或DataFrame列的聚合运算其实就是用 1.aggregate（使用自定义函数） 2.mean，sum等方法 更多的其他分组运算： 1.在GroupBy上使用transform方法(将一个函数应用到各个分组，然后将结果放置到适当的位置上） dataframe.groupby(‘key’).transform(np.mean)——这里就是np的平均值方法。 2.apply（对对象的拆分-应用-合并） 小例子：随机采样和排列 从一个大数据集中随机抽取样本以进行蒙特卡罗模拟。 np.random.permutation（N）的前K个元素。K为期望的样本大小，N为完整数据的大小。 交叉表：crosstab 用于计算分组频率的特殊透视表 pd.crosstab(data.index1,data.index2,margins = True) 前面两个参数可以是数组、Series或者数组列表。 数据加载、存储与文件格式 输入输出常分为几个类： **1.**读取文本文件或其他更高效的磁盘存储格式 2.加载数据库中的数据，利用web API操作网络资源 pandas有几种可以读取数据的方法，用的比较多的： 1.pd.read_csv(csv文件），默认分割符号为逗号的文件 2.pd.read_table(csv文件，sep = ‘分割标志’） 遇到没有标题行的文件，我们可以自己设置标题 pd.read_csv(文件名，names = [‘a’,’b’,’c’,’d….] 希望将多个列做成一个层次化索引，传入列名组成的列表： pd.readcsv(文件，index_col= [‘key’1,’key2’] 需要处理有缺失数据的dataframe时，可以传递参数na_values pd.readcsv(‘文件名’，na_values= [‘NULL’]) 这个方括号很重要，每次我都容易忘掉。 当文件特别大，不便于一次读取时，可以用 nrow =n，来选择先读取n行。 书p168有一个很好的例子，先选数据，然后利用循环进行聚合。 如何将数据写到文本呢——data.to_csv(文件） 读取Microsoft Excel文件： pd.ExcelFile（‘data.xls’）——创建一个excelfile实例 pd.ExcelFile.parse（‘sheet1’）读取存放在某个工作表的数据","categories":[],"tags":[]},{"title":"Python学习（续）","slug":"Python学习（续）","date":"2021-03-20T01:32:41.000Z","updated":"2021-03-20T01:33:24.682Z","comments":true,"path":"2021/03/20/Python学习（续）/","link":"","permalink":"http://example.com/2021/03/20/Python%E5%AD%A6%E4%B9%A0%EF%BC%88%E7%BB%AD%EF%BC%89/","excerpt":"","text":"本文是接着上面python语法书继续的。之所以愤慨来写，算是从pyhon的内（语法）到外（外部程序之间的互动）来变化的。下面让我们开始新的旅程！ 第十章 文件和异常 10.1 从文件中读取数据 1.读取整个文件： 先打开这个文件：with open（文件名）as x（自己起个名）： 定义一个变量A——A=文件名.read（），再print这个变量就好咯 10.1.2 文件路径 分为相对路径和绝对路径。相对文件路径让 Python 到指定的位置去查找，而该位置是相对于当前运行的程序所在目录的。绝对路径就是完整的最详细的位置。 12file_path = &#x27;/home/ehmatthes/other_files/text_files/filename.txt&#x27;with open(file_path) as file_object:#给出绝对路径的例子 10.1.3逐行读取： for 循环—— for line in X：；如果需要把换行空格去掉，用line.rstrip（） 10.1.4创建一个包含文件各行内容的列表 X.readlines() 从文件中读取每一行，并将其存储在一个列表中. ps：读取文本文件时， Python 将其中的所有文本都解读为字符串。如果你读取的是数字，并要将其作为数值使用，就必须使用函数 int() 将其转换为整数，或使用函数 float() 将其转换为浮点数。 可使用方法 replace() 将字符串中的特定单词都替换为另一个单词 replace（‘a’，’b’）用b将a替换了。 10.2 写入、操作文件 1with open（文件名，“模式”）as file： 这里的模式有几种：‘w’写入模式；‘r’读取模式；’a’附加模式；‘r+’读取+写入模式； 写入模式，如果文件名称相同，会自动清空先前同名文件。写入的方法：X.write() ps：Python 只能将字符串写入文本文件。要将数值数据存储到文本文件中，必须先使用函数 str() 将其转换为字符串格式。 10.3 异常 异常是使用 try-except 代码块处理的。 try-except 代码块让 Python 执行指定的操作，同时告诉 Python 发生异常时怎么办。使用了 try-except 代码块时，即便出现异常，程序也将继续运行：显示你编写的友好的错误消息，而不是令用户迷惑的 traceback 。 1234try: print(5/0)except ZeroDivisionError: print(&quot;You can&#x27;t divide by zero!&quot;) try-except语句块应该最好和else一起；错了就try-except，对了就else。 10.3.6 分析文本 1.计算文本数字个数——X.split（） 方法 split() 以空格为分隔符将字符串分拆成多个部分，并将这些部分都存储到一个列表中。列表中的元素个数就是文本个数 2.使用多个文件，都差不多。多个文件用for循环。 10.4 储存数据——模块json 模块 json 让你能够将简单的 Python 数据结构转储到文件中，并在程序再次运行时加载该文件中的数据。 10.4.1 json.dump（）和json.load（） json.dump（文件数据，将要储存文件数据的文件名） X.json——将X文件变为json的数据格式 12345import jsonnumbers = [2, 3, 5, 7, 11, 13]filename = &#x27;numbers.json&#x27; with open(filename, &#x27;w&#x27;) as f_obj:json.dump(numbers, f_obj) json.load(文件名)——读取文件 学习了：如何使用文件；如何一次性读取整个文件，以及如何以每次一行的方式读取文件的内容；如何写入文件，以及如何将文本附加到文件末尾；什么是异常以及如何处理程序可能引发的异常；如何存储 Python 数据结构，以保存用户提供的信息，避免用户每次运行程序时都需要重新提供。 11 测试函数 Python 标准库中的模块 unittest 提供了代码测试工具。 单元测试： 用于核实函数的某个方面没有问题 测试用例： 是一组单元测试，这些单元测试一起核实函数在各种情形下的行为都符合要求。良好的测试用例考虑到了函数可能收到的各种输入，包含针对所有这些情形的测试。 全覆盖式测试 ：包含一整套单元测试，涵盖了各种可能的函数使用方式。 新手可以先不考虑，后期进入学习。 彻底的进入了项目的实践过程，路漫漫其修远兮！！！有三个项目： 1.使用 Python 开发游戏 2.数据可视化 3.Web 应用程序 第一个我选择的是数据可视化。 1.1.使用matplotlib绘制简单的折线图 .pylot模块中有很多用于生成图标的函数. plt.show() 打开 matplotlib 查看器，并显示绘制的图形。.polt（）用于生成数据的函数 1234import matplotlib.pyplot as pltsquares = [1, 4, 9, 16, 25]plt.plot(squares)plt.show() 1.2.修改标签文字和线条粗细——参数linewidth决定了绘制线条的粗细；fontsize决定了字体的大小;title,xlable,ylable;tick_params决定了刻度的样式，lablesize表示刻度的大小 12345678import matplotlib.pyplot as pltsuqares=[2,4,5,6,7,8,9,10]plt.plot（squares，linewidth=10）plt.title（&quot;Fucking Mother&quot;,fontsize=10）plt.xlable(&quot;frequency&quot;,fontsize=5)plt.ylable(&quot;times&quot;,fontsize=5)plt.tick_params(axis=&#x27;both&#x27;, labelsize=14)plt.show（） 1.3.矫正polt图形定制——主动给出输入值和对应的输出值，这样就肯定不会出错（因为默认plot函数中给出的第一个值的x坐标为0） 123456789import matplotlib.pylot as pltinputs=[1,2,3,4,5,6,7]outputs=[1,4,9,16,25,36,49]plt.plot(inputs,outputs,linewidth=10)plt.title(&quot;HELLO&quot;,fontsize=14)plt.xlable(&quot;frequency&quot;,fontsize=10)plt.ylable(&quot;time&quot;,fontsize=10)plt.tick_params(axis=&quot;both&quot;,lablesize-10)plt.show() 2.1使用 scatter() 绘制散点图并设置其样式——要绘制单个点，可使用函数 scatter() ，并向它传递一对 x 和 y 坐标，它将在指定位置绘制一个点。 2.2绘制一系列的点：用range！ 1234567891011import matplotlib.pyplot as pltx_values = list(range(1, 1001))#这是精华，也是核心y_values = [x**2 for x in x_values]plt.scatter(x_values, y_values, s=40)plt.title(&quot;HELLO&quot;,fontsize=14)plt.xlable(&quot;frequency&quot;,fontsize=10)plt.ylable(&quot;time&quot;,fontsize=10)plt.tick_params(axis=&quot;both&quot;,lablesize-10)# 设置每个坐标轴的取值范围plt.axis([0, 1100, 0, 1100000])plt.show() 2.3删除数据点的轮廓（迷惑ing）：说什么点太多会糊起来…..edgcolor=‘none’即可删除 1plt.scatter(x_values, y_values, edgecolor=&#x27;none&#x27;, s=40) 2.4自定义点的颜色 12plt.scatter(x_values.y_values,c=&quot;red&quot;,edgcolor=&quot;none&quot;,s=50)plt.scatter（x_values.y_values,c=(0,0,1),edgcolor=&quot;none&quot;,s=50）#用RGB来表示色点 2.5使用随机映射：。在可视化中，颜色映射用于突出数据的规律，例如，你可能用较浅的颜色来显示较小的值，并使用较深的颜色来显示较大的值。cmap为参数——plt.cm.颜色 12345import matplotlib.pyplot as pltx_values = list(range(1001))y_values = [x**2 for x in x_values]plt.scatter(x_values, y_values, c=y_values, cmap=plt.cm.Blues,edgecolor=&#x27;none&#x27;, s=40) 3.1随机漫步——用python生成随机数据，并用matplotlib可视化。 123456789101112131415161718192021222324252627282930from random import choice#这里我们使用了很多的choice（）函数class RandomWalk():&quot;&quot;&quot; 一个生成随机漫步数据的类 &quot;&quot;&quot;def __init__(self, num_points=5000):&quot;&quot;&quot; 初始化随机漫步的属性 &quot;&quot;&quot;self.num_points = num_points# 所有随机漫步都始于 (0, 0)self.x_values = [0]self.y_values = [0]def fill_walk(self):&quot;&quot;&quot; 计算随机漫步包含的所有点 &quot;&quot;&quot;# 不断漫步，直到列表达到指定的长度while len(self.x_values) &lt; self.num_points:# 决定前进方向以及沿这个方向前进的距离x_direction = choice([1, -1])#选择方向，1或者-1，1为正方向，-1为负方向x_distance = choice([0, 1, 2, 3, 4])#每次走的步长可以从0选到4x_step = x_direction * x_distancey_direction = choice([1, -1])y_distance = choice([0, 1, 2, 3, 4])y_step = y_direction * y_distance# 拒绝原地踏步if x_step == 0 and y_step == 0:continue# 计算下一个点的 x 和 y 值next_x = self.x_values[-1] + x_stepnext_y = self.y_values[-1] + y_stepself.x_values.append(next_x)self.y_values.append(next_y) 接下来用matplotlib可视化： 1234567import matplotlib.pyplot as pltfrom random_walk import RandomWalk# 创建一个 RandomWalk 实例，并将其包含的点都绘制出来rw = RandomWalk()rw.fill_walk()plt.scatter(rw.x_values, rw.y_values, s=15)plt.show() 给大家看一下跑的成果吧（中间跑的过程也是一波三折，里面有很多逻辑递归的小问题） 自定义颜色了一下 ps：如果想要多次随机漫步：放在while循环，通过input输入yes or no来判断true/false（停止，继续） 3.2设置随机漫步图的样式（接着之前的随机漫步文件） 12345point_numbers = list(range(rw.num_points))plt.scatter(rw.x_values, rw.y_values, c=point_numbers, cmap=plt.cm.Blues,edgecolor=&#x27;none&#x27;, s=15)plt.show()keep_running = input(&quot;Make another walk? (y/n): &quot;) 跑了几次每次图片都不一样哈哈。 突出了起点和终点！ 1234567891011import matplotlib.pyplot as pltfrom random_walk import RandomWalk# 创建一个 RandomWalk 实例，并将其包含的点都绘制出来rw = RandomWalk()rw.fill_walk()point_numbers = list(range(rw.num_points))plt.scatter(rw.x_values, rw.y_values, c=point_numbers, cmap=plt.cm.Blues,edgecolor=&#x27;none&#x27;, s=15)plt.scatter(0,0,c=&quot;green&quot;,s=100)plt.scatter(rw.x_values[-1],rw.y_values[-1],c=&quot;red&quot;,s=100)plt.show() 3.3.2隐藏坐标轴的方法： 12plt.axes().get_xaxis().set_visible(False)plt.axes().get_yaxis().set_visible(False) 3.3.3设置绘图框口的尺寸： figure() 用于指定图表的宽度、高度、分辨率和背景色。你需要给形参 figsize 指定一个元组，向 matplotlib 指出绘图窗口的尺寸，单位为英寸。 1plt.figure(dpi=128, figsize=(10, 6) 在这本书里，我们只是很浅的入门了这个绘图包matplotlib。在后续的学习中，会更加深入的学习这个的! 继续学习另一个可视化包 pygal：我们将使用 Python 可视化包 Pygal 来生成可缩放的矢量图形文件。对于需要在尺寸不同的屏幕上显示的图表，它们将自动缩放，以适合观看者的屏幕。 创建一个模拟投色子的类，可以展现直方图 123456789101112131415161718192021222324from random import randintimport pygalclass die(): def _init_(self,num_sides=6): self.num_sides=num_sides def roll(self): return randint(1,self.num_sides)#randint 返回1到num_sides中的随机任意数die=Die（）#这算是给一个类赋予了一个实例！！！后面die就相当于有这个类了，die.method,就是class 里面的方法！results = []for roll_num in range(1000):result = die.roll()results.append(result)frequencies = []for value in range(1, die.num_sides+1):frequency = results.count(value)frequencies.append(frequency)hist = pygal.Bar()hist.title = &quot;Results of rolling one D6 1000 times.&quot;hist.x_labels = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;]hist.x_title = &quot;Result&quot;hist.y_title = &quot;Frequency of Result&quot;hist.add(&#x27;D6&#x27;, frequencies)hist.render_to_file(&#x27;die_visual.svg&#x27;) 为创建条形图，我们创建了一个 pygal.Bar() 实例，并将其存储在 hist 中，类似于外包中的类。设置 hist 的属性 title （用于标示直方图的字符串），将掷 D6 骰子的可能结果用作 x 轴的标签并给每个轴都添加了标题。我们使用 add() 将一系列值添加到图表中（向它传递要给添加的值指定的标签，还有一个列表，其中包含将出现在图表中的值）。最后，我们将这个图表渲染为一个 SVG 文件，这种文件的扩展名必须为 .svg 。 给出结果：（需要变成SVG文件在网页中打开） 在本章中，学习了：如何生成数据集以及如何对其进行可视化；如何使用 matplotlib 创建简单的图表，以及如何使用散点图来探索随机漫步过程；如何使用 Pygal 来创建直方图，以及如何使用直方图来探索同时掷两个面数不同的骰子的结果。 下载数据并进行可视化 1.CSV文件格式 要在文本文件中存储数据，最简单的方式是将数据作为一系列 以逗号分隔的值 （ CSV ）写入文件。一般python用CSV模块来读取处理CSV文件数据。 123456import csvfilename = &#x27;sitka_weather_07-2014.csv&#x27;with open(filename) as f:reader = csv.reader(f)#csv.reader（）用来读取文件header_row = next(reader)#函数next，用它并将阅读器对象传递给它时，它将返回文件中的下一行print(header_row) reader 处理文件中以逗号分隔的第一行数据，并将每项数据都作为一个元素存储在列表中。 1.2打印文件头及其位置——列表调用了 enumerate() 来获取每个元素的索引及其值,阅读器对象从其停留的地方继续往下读取 CSV 文件，每次都自动返回当前所处位置的下一行。 1234567891011import csvfilename = &#x27;sitka_weather_07-2014.csv&#x27;with open(filename) as f:reader = csv.reader(f)header_row = next(reader)for index, column_header in enumerate(header_row):print(index, column_header)highs=[]for row in reader()： highs.append（row[1])print(highs) 1.3模块datetime——将一些字符串数据转换成相应对应的日期对象，使用了datetime.strptime（X，Y）x为字符串实参，y为对应的设置格式（通过-来断开） 1234from datetime import datetimefirst_date = datetime.strptime(&#x27;2014-7-1&#x27;, &#x27;%Y-%m-%d&#x27;)print(first_date)2014-07-01 00:00:00 模块 datetime 中设置日期和时间格式的实参： %A（星期英文）；%B（月份英文）；%M（月份数字）；%D(月中的某一天数字）；%Y（四位的年份数字）；%y（两位的年份数字）；%H（24小时的小时数）；%I(12小时的小时数）；%p（am或pm）；%M（分钟数）%S（秒数） 123456789101112131415161718192021222324import csvfrom datetime import datetimefrom matplotlib import pyplot as plt# 从文件中获取日期和最高气温filename = &#x27;sitka_weather_07-2014.csv&#x27;with open(filename) as f:reader = csv.reader(f)header_row = next(reader)dates, highs = [], []for row in reader:current_date = datetime.strptime(row[0], &quot;%Y-%m-%d&quot;)dates.append(current_date)high = int(row[1])highs.append(high)# 根据数据绘制图形fig = plt.figure(dpi=128, figsize=(10, 6))plt.plot(dates, highs, c=&#x27;red&#x27;)# 设置图形的格式plt.title(&quot;Daily high temperatures, July 2014&quot;, fontsize=24)plt.xlabel(&#x27;&#x27;, fontsize=16)fig.autofmt_xdate()#调用了 fig.autofmt_xdate() 来绘制斜的日期标签，以免它们彼此重叠。plt.ylabel(&quot;Temperature (F)&quot;, fontsize=16)plt.tick_params(axis=&#x27;both&#x27;, which=&#x27;major&#x27;, labelsize=16)plt.show() 如果是需要在一个表格中绘制多个数据：也就是多一个列表，然后plot（这是最简单的形式，后面还有很多复杂的）其实这个思维还蛮重要 12345678910111213141516171819filename = &#x27;sitka_weather_2014.csv&#x27;with open(filename) as f:reader = csv.reader(f)header_row = next(reader)dates, highs, lows = [], [], []for row in reader:current_date = datetime.strptime(row[0], &quot;%Y-%m-%d&quot;)dates.append(current_date)high = int(row[1])highs.append(high)low = int(row[3])lows.append(low)# 根据数据绘制图形fig = plt.figure(dpi=128, figsize=(10, 6))plt.plot(dates, highs, c=&#x27;red&#x27;)plt.plot(dates, lows, c=&#x27;blue&#x27;) # 设置图形的格式 plt.title(&quot;Daily high and low temperatures - 2014&quot;, fontsize=24)--snip-- 2.1 开始json文件的可视化 （回顾一下字典：X[键]=值）因为json的格式和字典很像！处理json文件的话，一般是把json格式转化为python中的字典。 print只能打印字符串，如果有数字先变成str格式。 1234567891011import json# 将数据加载到一个列表中filename = &#x27;population_data.json&#x27;with open(filename) as f:pop_data = json.load(f)# 打印每个国家 2010 年的人口数量for pop_dict in pop_data:if pop_dict[&#x27;Year&#x27;] == &#x27;2010&#x27;:country_name = pop_dict[&#x27;Country Name&#x27;]population = pop_dict[&#x27;Value&#x27;]print(country_name + &quot;: &quot; + population) Python 不能直接将包含小数点的字符串 ‘1127437398.85751’ 转换为整数。为消除这种错误，我们先将字符串转换为浮点数，再将浮点数转换为整数int（float（12345））——类似于四舍五入吧. 下面用pygal来描绘世界地图：主要用了pygal.worldmap（） pygal.worldmap.add（）——它接受一个标签和一个列表，其中后者包含列表数据（数据可以现场填入修改）。每次调用 add() 都将为指定列表数据选择一种新颜色，并在图表左边显示该颜色和指定的标签。（这个我已经玩过了hhhhh） pygal.style（）可以设计一些图表的样式 12345678import pygal❶ wm = pygal.Worldmap()wm.title = &#x27;North, Central, and South America&#x27;❷ wm.add(&#x27;North America&#x27;, [&#x27;ca&#x27;, &#x27;mx&#x27;, &#x27;us&#x27;])wm.add(&#x27;Central America&#x27;, [&#x27;bz&#x27;, &#x27;cr&#x27;, &#x27;gt&#x27;, &#x27;hn&#x27;, &#x27;ni&#x27;, &#x27;pa&#x27;, &#x27;sv&#x27;])wm.add(&#x27;South America&#x27;, [&#x27;ar&#x27;, &#x27;bo&#x27;, &#x27;br&#x27;, &#x27;cl&#x27;, &#x27;co&#x27;, &#x27;ec&#x27;, &#x27;gf&#x27;,&#x27;gy&#x27;, &#x27;pe&#x27;, &#x27;py&#x27;, &#x27;sr&#x27;, &#x27;uy&#x27;, &#x27;ve&#x27;])❸ wm.render_to_file(&#x27;americas.svg&#x27;) 学习了：如何处理 CSV 和 JSON 文件，以及如何提取你感兴趣的数据；如何使用 matplotlib 来处理以往的天气数据，包括如何使用模块 datetime ，以及如何在同一个图表中绘制多个数据系列；如何使用 Pygal 绘制呈现各国数据的世界地图，以及如何设置 Pygal 地图和图表的样式。有了使用 CSV 和 JSON 文件的经验后，将能够处理几乎任何要分析的数据。大多数在线数据集都可以以这两种格式中的一种或两种下载。 学习使用API—— Web 应用编程接口 Web API 是网站的一部分，用于与使用非常具体的 URL 请求特定信息的程序交互。这种请求称为 API 调用。请求的数据将以易于处理的格式（如 JSON 或 CSV ）返回。 1.2request包&amp;处理API响应（似乎就是多了一步哎…） 123456789import requests# 执行 API 调用并存储响应url = &#x27;https://api.github.com/search/repositories?q=language:python&amp;sort=stars&#x27;r = requests.get(url)#调用 get() 并将 URL 传递给它，再将响应对象存储在变量 r 中。响应对象包含一个名为 status_code 的属性，它让我们知道请求是否成功了（状态码 200 表示请求成功）print(&quot;Status code:&quot;, r.status_code)# 将 API 响应存储在一个变量中response_dict = r.json()#python会自动的parse json格式进入字典格式# 处理结果print(response_dict.keys()) 1.3利用pygal将仓库信息可视化 1234567891011121314151617181920212223import requestsimport pygalfrom pygal.style import LightColorizedStyle as LCS, LightenStyle as LS# 执行 API 调用并存储响应URL = &#x27;https://api.github.com/search/repositories?q=language:python&amp;sort=star&#x27;r = requests.get(URL)print(&quot;Status code:&quot;, r.status_code)# 将 API 响应存储在一个变量中response_dict = r.json()print(&quot;Total repositories:&quot;, response_dict[&#x27;total_count&#x27;])# 研究有关仓库的信息repo_dicts = response_dict[&#x27;items&#x27;]names, stars = [], []for repo_dict in repo_dicts:names.append(repo_dict[&#x27;name&#x27;])stars.append(repo_dict[&#x27;stargazers_count&#x27;])# 可视化my_style = LS(&#x27;#333366&#x27;, base_style=LCS)chart = pygal.Bar(style=my_style, x_label_rotation=45, show_legend=False)chart.title = &#x27;Most-Starred Python Projects on GitHub&#x27;chart.x_labels = nameschart.add(&#x27;&#x27;, stars)chart.render_to_file(&#x27;python_repos.svg&#x27;) 主要看pygal；我们使用 LightenStyle 类（别名 LS ）定义了一种样式，并将其基色设置为深蓝色。我们还传递了实参 base_style ，以使用 LightColorizedStyle类（别名 LCS ）。然后，我们使用 Bar() 创建一个简单的条形图，并向它传递了 my_style。我们还传递了另外两个样式实参：让标签绕 x 轴旋转 45 度 x_label_rotation=45。我们给图表定了标题，并将属性 x_labels设置为列表 names 。 1.4在图标中给出可点击的链接——只需添加一行代码，在为每个项目创建的字典中，添加一个键为 ‘xlink’ 的键 — 值对。 1‘xlink’：字典名[&#x27;html_url&#x27;] 学习了：如何使用 API 来编写独立的程序，它们自动采集所需的数据并对其进行可视化；使用 GitHub API 来探索 GitHub 上星级最高的 Python 项目.如何使用 requests 包来自动执行 GitHub API 调用，以及如何处理调用的结果。还简要地介绍了一些 Pygal 设置，使用它们可进一步定制生成的图表的外观。 到此为止，可视化的项目就全部结束了。","categories":[],"tags":[]},{"title":"Python学习","slug":"Python学习","date":"2021-03-20T01:30:45.000Z","updated":"2021-03-20T01:32:00.712Z","comments":true,"path":"2021/03/20/Python学习/","link":"","permalink":"http://example.com/2021/03/20/Python%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"python基础语法学习——参考Python Crash Course 小刘长点薪 用我的眼，看来往的路，看变化万端的自己. 关注他 4 人赞同了该文章 第一章：python在各个系统之间的安装和使用（略） 第二章： 变量 2.1.每个变量都存储了一个值 ——与变量相关联的信息.在程序中可随时修改变量的值，而 Python将始终记录变量的最新值。 2.2变量名只能包含字母、数字和下划线，不能有空格。变量名可以字母或下划线打头，但不能以数字打头。 小练习：将一条消息存储到变量中，再将其打印出来。#print只能打印变量和字符串，不能打数字和字母！ 12Liuyuanji=&quot;He is so handsome!&quot;print(Liuyuanji) 字符串 2.3字符串就是一系列字符。在Python中，用引号括起的都是字符串，其中的引号可以是单引号，也可以是双引号.没什么区别. 单独的字符串需要有引号来引用，数字就不用了。 1&quot;He said&#x27;i don&#x27;t like you.&#x27;&quot; 2.3.1将字符串进行大小写的改变——X.title（）title() 以首字母大写的方式显示每个单词，即将每个单词的首字母都改为大写。 12AK=&quot;taylor swift&quot;print(AK.title()) 2.3.2 将字母全部变成大写——x.upper（）；将字母全部变成小写x.lower（） 2.3.3合并（拼接）字符串，在python中使用“+”号来连接字符串. 1234A=&quot;John&quot;B=&quot;NYU&quot;C=A+&quot; &quot;+Bprint(C) 可以再来一句话给出一个例子来试验。这里需要注意的地方（我自己写出错的地方）：在print语句中，如果是单纯的字符（字母和符号），是需要用引号隔开的，如果是字符串就不用啦） 12A=&quot;John,I love you baby!&quot;print(&quot;Hello,I wanna tell you:&quot;+A) 2.3.4使用制表符或换行符来添加空白: 可使用字符组合 \\t来添加制表符（多一个tap）；可以使用\\n来添加换行符。害，我刚才又出现了一个错误：制表符是要放在字符前面的！然后最后一行不要换行了……. 12print（&quot;\\tHello,John!&quot;）print(&quot;name:\\nage:\\ngender:&quot;) ps：还可在同一个字符串中同时包含制表符和换行符。字符串 “\\n\\t” 让 Python 换到下一行，并在下一行开头添加一个制表符。 2.3.5删除空白： \\1. Python 能够找出字符串开头和末尾多余的空白。要确保字符串末尾没有空白，可使用方法 .rstrip() 这里的删除只是暂时的，也可以理解为把删除空白格的变量成了一个新的变量。要永久删除这个字符串中的空白，必须将删除操作的结果存回到变量中。 2.同理：还可以剔除字符串开头的空白，或同时剔除字符串两端的空白。为此，可分别使用方法 lstrip() 和 strip() ：（具体不写example了） 12345A=&quot;NYU &quot;B=A.rstrip()print(B)A=Bprint（A） 2.4 数字 2.4.1 整数运算（略）:加（ + ）减（ - ）乘（ * ）除（ / ）；Python 使用两个乘号表示乘方运算 2.4.2浮点数（小数）（略） 2.4.3关于将非字符数变成字符数：str（x） 我的错误我以为是x.str（） 12age=20print(&quot;John is &quot;+str(age)+&quot; old&quot;) 2.5注释（一个很有用的技能） 在 Python 中，注释用井号（ # ）标识。井号后面的内容都会被 Python 解释器忽略。 1print(&quot;I LOVE TAYLOR SWIFT!&quot;)#DBDFHOIHDOICIOSAFOIIFCEO 在本章中，学习了：如何使用变量；如何创建描述性变量名以及如何消除名称错误和语法错误；字符串是什么，以及如何使用小写、大写和首字母大写方式显示字符串；使用 空白来显示整洁的输出，以及如何剔除字符串中多余的空白；如何使用整数和浮点数；使用数值数据时需要注意的意外行为。你还学习了如何编写说明性注释，让代码对你和其 他人来说更容易理解。最后，你了解了让代码尽可能简单的理念。 第三章：列表简介 在 Python 中，用方括号（ [] ）来表示列表： 12My Favorite singer=([Taylor Swift],[justin bieber])#这是我第一次的错误MY Favorite singer=[&quot;Taylor Swift&quot;,&quot;Justin Bieber&quot;]#这个就是第二次正确的一个列表 3.1.1访问列表元素，只需将该元素的位置或索引告诉 Python 即可。（索引位置是从0开始而不是1,算是常识） 12MY Favorite singer=[&quot;Taylor Swift&quot;,&quot;Justin Bieber&quot;]print（MY Favorite singer[1])#这样给出的就是Justin Bieber了 3.1.2使用列表中的各个值。这个其实和一开始用非字符串当做字符串是一样的。我觉得如果列表中的元素不是字符串的话，可能还需要用一个str（）吧。 12bicycles = [&#x27;trek&#x27;, &#x27;cannondale&#x27;, &#x27;redline&#x27;, &#x27;specialized&#x27;] message = &quot;My first bicycle was a &quot; + bicycles[0].title() + &quot;.&quot; 3.2 修改、添加和删除元素 3.2.1 修改列表元素： 修改列表元素的语法与访问列表元素的语法类似。要修改列表元素，可指定列表名和要修改的元素的索引，再指定该元素的新值。 123bicycles = [&#x27;trek&#x27;, &#x27;cannondale&#x27;, &#x27;redline&#x27;, &#x27;specialized&#x27;]bocycles[2]=&quot;red&quot;print(bicycles) 3.2.2 增加列表元素：X.append（）将一个新的元素加入到列表的末尾。（注意，不是加新的列表，而是列表元素哦，我一开始学的时候列表个数和列表元素老是分不清） ps:小技巧：可首先创建一个空列表，用于存储用户将要输入的值，然后将 用户提供的每个新值附加到列表中。 3.2.3在列表中插入元素，如果要插入的话，确定两个变量就好咯——索引，和元素内容。 用X.insert（a,b）——a为列表中的索引，b为元素内容： 123bicycles = [&#x27;trek&#x27;, &#x27;cannondale&#x27;, &#x27;redline&#x27;, &#x27;specialized&#x27;]bicycles.insert(3,&#x27;good&#x27;)print(bicycles) 3.2.4从列表中删除元素 如果知道要删除的元素在列表中的位置，可使用 del 语句。注意，是语句。 123bicycles = [&#x27;trek&#x27;, &#x27;cannondale&#x27;, &#x27;redline&#x27;, &#x27;specialized&#x27;]del bicycles[1]#语句不需要加括号吧print(bicycles) 使用方法 pop() 删除元素。pop（）可以删除列表中的最后一个元素.如果需要使用删去的那个元素，创建一个新的变量保存吧。 123bicycles = [&#x27;trek&#x27;, &#x27;cannondale&#x27;, &#x27;redline&#x27;, &#x27;specialized&#x27;]Ok=bicycles.pop()#Ok就是代表了最后一个元素了print(bicycles)#这个时候就会给出失去最后一个元素的原本列表bicycles了 3.2.5从列表中弹出任何位置的元素。用pop（x），其中x就是代表元素在列表中的索引位置。如果想使用：先用pop（）删去，然后用新的变量表示删去的，再引用新的变量，就开业弹出了。 ps:如果用del语句删除就无法再引用了，如果用pop（）就还可以。（例子也可以用上面的） 3.2.6根据值删除元素 remove(x)具体的比pop（x）差不多吧我感觉。 123bicycles = [&#x27;trek&#x27;, &#x27;cannondale&#x27;, &#x27;redline&#x27;, &#x27;specialized&#x27;]apple=bicycles.remove（&quot;redline&quot;）print(bicycles) 3.3组织列表 3.3.1 使用方法 sort() 对列表进行永久性排序（按字母顺序排序);你还可以按与字母顺序相反的顺序排列列表元素，为此，只需向 sort() 方法传递参数 reverse=True 。这里的永久性我的理解就是电脑删去了原本的样子没有copy了。彻底改变回不去。 12345cars = [&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;]cars.sort()print(cars)cars.sort(reverse=True)#为什么是这样的形式呢？print（cars） 3.3.2使用函数 sorted() 对列表进行临时（按字母顺序）排序。这样的话就相当于出现了新的排序，但是原本的也有备份吧。 123cars = [&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;]cars.sorted()print(cars) 3.3.3倒着打印列表 reverse().将列表的元素顺序颠倒显示。reverse的修改也是永久性的，无备份。 3.3.4确定列表长度——len（）ps：列表长度从1开始 关于索引的顺序：从左往右从0开始，从右往左从-1开始。 在本章中，学习了：列表是什么以及如何使用其中的元素；如何定义列表以及如何增删元素；如何对列表进行永久性排序，以及如何为展示列表而进行临时排序；如何确定列表的长度，以及在使用列表时如何避免索引错误。 第 4 章 操作列表 4.1 遍历整个列表——用for循环就可 （for X in Y：） 4.1.2 在 for 循环中执行更多的操作，其实也就多了之前的结合。 123magicians = [&#x27;alice&#x27;, &#x27;david&#x27;, &#x27;carolina&#x27;]for x in magicians： print（x.title（）+“is a good person！”） 在 for 循环后面，没有缩进的代码都只执行一次，而不会重复执行。缩进不缩进，关乎着逻辑的问题。只有要在 for 循环中对每个元素执行的代码需要缩进（目前）。还有一个！！！千万别忘记了冒号。 4.2 创建数值列表 4.2.1 使用函数 range() 1234for X in range(a,b）: print(x)#给出来的结果应该是a到b-1for X in range（a，b，3） print(x)#这里range多了一个步长，算是数列中的差吧 不写默认为1 4.2.2 使用 range() 创建数字列表：用list（），将range（）变成list（）中的参数。 4.2.3 max(); min();sum() 4.2.4.列表解析 用一行代码来实现循环 12squares = [value**2 for value in range(1,11)]print(squares) 就个人感觉，如有小misson：一般先创建一个空列表，然后for循环填进去，然后在用for print或者sum 都行。 4.3关于切片。与函数 range() 很相似吧， Python 在到达你指定的第二个索引前面的元素后停止。关于那种负数索引和正数索引用法和range（）一样。 1234players = [&#x27;charles&#x27;, &#x27;martina&#x27;, &#x27;michael&#x27;, &#x27;florence&#x27;, &#x27;eli&#x27;] print(players[0:3])#零对应第一个，一直切到3之前的元素，也就是2 print(players[:3])#没有首个元素的索引，默认从第一个开始 print(players[2:])#没有尾部元素的索引，默认一直开始到最后一个 4.3.2 遍历切片——用for循环进行列表切片索引就好 4.4.3 复制列表，可创建一个包含整个列表的切片，方法是同时省略起始索引和终止索引（ [:] ） 4.4. 4 元组—— Python 将不能修改的值称为 不可变的 ，而不可变的列表被称为元组 。元组是圆括号，列表是方括号。虽然不能修改元组的元素，但可以给存储元组的变量赋值。因此，如果要修改前述矩形的尺寸，可重新定义整个元组。（类似于重新写一个吧） 在本章中，学习了：如何高效地处理列表中的元素；如何使用for 循环遍历列表，Python如何根据缩进来确定程序的结构以及如何避免一些常见的缩进错误；如何创建简单的数字列表，以及可对数字列表执行的一些操作；如何通过切片来使用列表的一部分和复制列表。你还学习了元组（它对不应变化的值提供了一定程度的保护）。 第五章 if语句 5.2 条件测试 每条if 语句的核心都是一个值为True 或False 的表达式，这种表达式被称为条件测试 。 =：赋值；==等于；！=不等于 5.2.1多个条件测试（同时满足），可以用 and （类似与门）；多个条件测试（满足一个就可），可以用or（类似或门） 5.2.2判断特定的值是否已包含在列表中，可使用关键字in;确定特定的值未包含在列表中很重要；在这种情况下，可使用关键字not in 1234567Caffe=[&quot;ad&quot;,&quot;va&quot;] &quot;ad&quot; in Caffe:banned_users = [&#x27;andrew&#x27;, &#x27;carolina&#x27;, &#x27;david&#x27;] user = &#x27;marie&#x27; if user not in banned_users: print(user.title() + &quot;, you can post a response if you wish.&quot;) 5.3 if 语句学习 在if 语句中，缩进的作用与for 循环中相同。如果测试通过了，将执行if 语句后面所有缩进的代码行，否则将忽略它们。 123John= &quot;handsome&quot;if John=&quot;handsome&#x27;: print(&quot;He is so good! i wanna him&quot;) 5.3.2 if-else 语句，常常用于二选一的状态：通常else之后直接就是一个冒号就好了，因为只要不满足if，就是else。 1234if xxxxx： xxxxxxxxxxelse：xxxxxxx 5.3.3 if-elif-else 结构：也就多了一个选择吧，多个elif 123456ifxxxxx： xxxxxxxelif xxxxx： xxxxxxxxelse： xxxxx 5.3.4 多个elif结构。有时候可以不用else了，可以用一个具体的elif来代替else，会使得代码更加清晰。else 是一条包罗万象的语句，只要不满足任何if 或elif 中的条件测试，其中的代码就会执行，这可能会引入无效甚至恶意的数据。 上面的几个条件结构都是针对只需要满足其中一种的情况，如果需要多个条件独立检验（和有and or 的不一样的），则我们需要多个if语句来分开来独立检验。 5.3.5 用if语句使用多个列表： 12345678available_toppings = [&#x27;mushrooms&#x27;, &#x27;olives&#x27;, &#x27;green peppers&#x27;, &#x27;pepperoni&#x27;, &#x27;pineapple&#x27;, &#x27;extra cheese&#x27;] requested_toppings = [&#x27;mushrooms&#x27;, &#x27;french fries&#x27;, &#x27;extra cheese&#x27;] for requested_topping in requested_toppings: if requested_topping in available_toppings: print(&quot;Adding &quot; + requested_topping + &quot;.&quot;) else: print(&quot;Sorry, we don&#x27;t have &quot; + requested_topping + &quot;.&quot;) print(&quot;\\nFinished making your pizza!&quot;) 在本章中，学习了如何编写结果要么为Ture 要么为False 的条件测试。你学习了如何编写简单的if 语句、if-else 语句和if-elif-else 结构。在程序中，你使用了这些结构来测试特定的条件，以确定这些条件是否满足。学习了如何在利用高效的for 循环的同时，以不同于其他元素的方式对特定的列表元素进行处理。 第六章 字典 在 Python 中， 字典 是一系列 键 — 值对 。每个 键 都与一个值相关联，你可以使用键来访问与之相关联的值（print（键），然后输出值）。字典用放在花括号 {} 中的一系列键 — 值对表示 1cool=&#123;&quot;John&quot;:&quot;handsome&quot;,&quot;jack&quot;:&quot;ugly&quot;&#125;#字典中间需要用逗号隔开 6.2.2 添加键值对，很简单就是一行代码：X[添加的键]=添加的值。（x为已知的字典）；一般也可以先添加一个空的字典，然后一点点的往里面填键值对。 6.2.3修改键值对——要修改字典中的值，可依次指定字典名、用方括号括起的键以及与该键相关联的新值。其实和添加差不多。只是键名不是新的，而是已经存在的。 6.2.4对于字典中不再需要的信息，可使用 del 语句将相应的键 — 值对彻底删除。 del X[键名] 6.2.5 X.items() 可以返回一个对应的键和值： 12345message=&#123;&quot;Name&quot;:&quot;John&quot;,&quot;Age&quot;:20,&quot;Gender&quot;:&quot;male&quot;&#125;for key,value in message.items():#一定要有2个变量，分别对应键，值 print(\\n&quot;Key is:&quot;+key) print(&quot;Value is:&quot;+value)#跑数字的时候还需要用str单独搞一下。可以考虑使用if elif结构 6.2.6遍历字典中的所有键 for循环+keys()方法 keys() 并非只能用于遍历；实际上，它返回一个列表，其中包含字典中的所有键。 6.3 按顺序遍历字典的所有键：还是for循环+sorted()顺序功能。 ps：是要获取所有字典的值的话：for循环+values（）即可。如果值出现了重复，使用set（）即可。 123456789favorite_languages = &#123;&#x27;jen&#x27;: &#x27;python&#x27;,&#x27;sarah&#x27;: &#x27;c&#x27;,&#x27;edward&#x27;: &#x27;ruby&#x27;,&#x27;phil&#x27;: &#x27;python&#x27;,&#125;print(&quot;The following languages have been mentioned:&quot;)for language in set(favorite_languages.values()): print(language.title()) 6.4嵌套 系列字典存储在列表中，或将列表作为值存储在字典中，这称为 嵌套。（类似于换元吧） 123456789101112131415161718alien_0 = &#123;&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5&#125;alien_1 = &#123;&#x27;color&#x27;: &#x27;yellow&#x27;, &#x27;points&#x27;: 10&#125;alien_2 = &#123;&#x27;color&#x27;: &#x27;red&#x27;, &#x27;points&#x27;: 15&#125;aliens = [alien_0, alien_1, alien_2]#这个就嵌套for alien in aliens:print(alien）pizza = &#123;&#x27;crust&#x27;: &#x27;thick&#x27;,&#x27;toppings&#x27;: [&#x27;mushrooms&#x27;, &#x27;extra cheese&#x27;],&#125;#这个也是嵌套 print(&quot;You ordered a &quot; + pizza[&#x27;crust&#x27;] + &quot;-crust pizza &quot; +&quot;with the following toppings:&quot;) for topping in pizza[&#x27;toppings&#x27;]:print(&quot;\\t&quot; + topping) 学习了：如何定义字典，以及如何使用存储在字典中的信息；如何访问和修改字典中的元素，以及如何遍历字典中的所有信息；如何遍历字典中所有的键 - 值对、所有的键和所有的值；如何在列表中嵌套字典、在字典中嵌套列表以及在字典中嵌套字典。 第 7 章 用户输入和 while 循环 7.1 函数 input()—-函数 input() 让程序暂停运行，等待用户输入一些文本。获取用户输入后， Python 将其存储在一个变量中。 7.1.2 使用 int() 来获取数值输入。int（x）x原本代表的是数字字符串，用了之后就转变成了数字类型了（不是字符串）。 7.1.3求模运算符 %(用来判断奇数偶数） 7.2while 循环。 就是给了一个条件（范围），让东西停止吧。主要因为那个范围不是给定的（就像那种完整的列表之类，可以用for来搞定）。一直运行到while后面的条件不满足为止。 123456prompt = &quot;\\nTell me something, and I will repeat it back to you:&quot;prompt += &quot;\\nEnter &#x27;quit&#x27; to end the program. &quot;message = &quot;&quot;while message != &#x27;quit&#x27;: message = input(prompt) print(message) 7.2.3使用标志 while X： x只需要等于true 作为是否进行的一个标志即可。 12345678john=&quot;Tell me love me ,baby!&quot;john+=&quot;\\nif you do,let us make love.&quot;active=Truewhile active: if message==&quot; No!&quot;: active=False else: print(message)## False &amp;True 要大写！ 7.2.4 使用 break 退出循环，有时候不方面确定明确的停止条件，就需要用break了。 12345678prompt = &quot;\\nPlease enter the name of a city you have visited:&quot;prompt += &quot;\\n(Enter &#x27;quit&#x27; when you are finished.) &quot;while True: city = input(prompt)if city == &#x27;quit&#x27;: breakelse: print(&quot;I&#x27;d love to go to &quot; + city.title() + &quot;!&quot;) 7.2.5 在循环中使用 continue 要返回到循环开头，并根据条件测试结果决定是否继续执行循环，可使用 continue 语句，它不像 break 语句那样不再执行余下的代码并退出整个循环。 .3.1 在列表之间移动元素:创建一个空的列表，原本的用pop调出，append调入，加上while循环即可。 学习了：如何在程序中使用 input() 来让用户提供信息；如何处理文本和数字输入，以及如何使用 while 循环让程序按用户的要求不断地运行；多种控制 while循环流程的方式：设置活动标志、使用 break 语句以及使用 continue 语句；如何使用 while 循环在列表之间移动元素，以及如何从列表中删除所有包含特定值的元素；如何结合使用 while 循环和字典。 第八章 函数 函数是带名字的代码块，用于完成具体的工作。 8.1定义函数 —— def X（）：x为函数名（函数名不需要加引号哦，不是字符串！） 后面可以直接地调用函数名 8.1.2将函数信息传递进去——在8.1的基础上，在括号里面填入变量，后期使用的时候变量为什么都可以直接带入函数式。可以说 填入的那个变量是形参，而后面真正调用进去的是实参。 1234def greet_user(username):&quot;&quot;&quot; 显示简单的问候语 &quot;&quot;&quot;print(&quot;Hello, &quot; + username.title() + &quot;!&quot;)greet_user(&#x27;jesse&#x27;)#这里变量就是username 8.2传递实参 8.2.1位置实参——多个形参和实参位置顺序一一对应。 123def greet_user(username,gender): print(&quot;Hello, &quot; + username.title() +&quot;,you are a&quot;+gender)greet_user(&#x27;jesse&#x27;,&#x27;girl&#x27;)#实参还是需要考虑是不是要加引号的 8.2.2关键字实参——用关键字实参来调用 describe_pet() 顺序不重要了，因为在形参里面已经将其一一对应。 8.2.3默认值实参，在def的时候就给参数赋值，如果不声明，那就是默认参数为已经提前赋过值的。**使用默认值时，在形参列表中必须先列出没有默认值的形参，再列出有默认值的实参。这让 Python 依然能够正确地解读位置实参。(**有explaination，但是记住比较好）有默认值的放在没有参数默认值的后面。 8.3 返回值 函数并非总是直接显示输出，相反，它可以处理一些数据，并返回一个或一组值。函数返回的值被称为返回值。 用return函数 return+X 可以返回字典，字符串，列表…….. 8.4传递列表：列表包含的可能是名字、数字或更复杂的对象（如字典）。结合for对列表进行循环。 如果要修改列表：老生常谈，先建立新列表，然后旧的pop，新的append。当然，如果不想原列表修改，可以创建copy版本：切片表示法 [:] 创建列表的副本 1print_models(unprinted_designs[:], completed_models) 8.5 传递任意数量的实参——将多个实参，用一个元组封装。（如果需要用位置实参，则把代表元组的那个形参放在最后位置) 8.6使用任意数量的关键字实参 :我们无法确认input会出现什么并且和什么一一对应时，我们可以将一个形参形式为字典。通过我们自己在那个字典中的键值对一一对应（for遍历），便可得到很好地信息。 123456789101112def build_profile(first, last, **user_info):&quot;&quot;&quot; 创建一个字典，其中包含我们知道的有关用户的一切 &quot;&quot;&quot;profile = &#123;&#125; profile[&#x27;first_name&#x27;] = firstprofile[&#x27;last_name&#x27;] = lastfor key, value in user_info.items(): profile[key] = valuereturn profileuser_profile = build_profile(&#x27;albert&#x27;, &#x27;einstein&#x27;,location=&#x27;princeton&#x27;,field=&#x27;physics&#x27;)print(user_profile) #这里的**user_info就是字典，加上我们用的for 在字典中的遍历，就可以得到完整消息。 8.6 将函数存储在模块中 用import+函数名 8.6.2使用 as 给函数指定别名 from xxx import xx as xxx.\\ import xxx as xxxx. 8.6.3使用星号（ * ）运算符可让 Python 导入模块中的所有函数(用的不多，如果是大模块函数，不得歇菜） 学习了：如何编写函数，以及如何传递实参，让函数能够访问完成其工作所需的信息；如何使用位置实参和关键字实参，以及如何接受任意数量的实参；显示输出的函数和返回值的函数；如何将函数同列表、字典、 if 语句和 while 循环结合起来使用。还知道了如何将函数存储在被称为 模块 的独立文件中。 第九章 类 编写类时，你定义一大类对象都有的通用行为。基于类创建 对象 时，每个对象都自动具备这种通用行为，然后可根据需要赋予每个对象独特的个性。 类，就是对象。类里面构造成员变量和成员函数；函数想成是方法，变量想成属性。 9.1.1 创建 Dog 类，给与这个特别的dog类特别的function——class x（） 123456789101112class Dog(): &quot;&quot;&quot; 一次模拟小狗的简单尝试 &quot;&quot;&quot; def __init__(self, name, age):&quot;&quot;&quot; 初始化属性 name 和 age&quot;&quot;&quot; self.name = nameself.age = age#这几步是必不可少的初始化过程！ def sit(self):&quot;&quot;&quot; 模拟小狗被命令时蹲下 &quot;&quot;&quot;print(self.name.title() + &quot; is now sitting.&quot;)def roll_over(self):&quot;&quot;&quot; 模拟小狗被命令时打滚 &quot;&quot;&quot;print(self.name.title() + &quot; rolled over!&quot;) 9.1.2 类中的函数都叫方法，普遍适用。（我目前的感觉好像如果没有必要创造类的话，可以直接创建函数，省去了很多麻烦） 方法 init() 定义成了包含三个形参： self 、 name 和 age 。在这个方法的定义中，形参 self 必不可少，还必须位于其他形参的前面。以 self 为前缀的变量都可供类中的所有方法使用，我们还可以通过类的任何实例来访问这些变量。 换句话说：self就是你一开始先创建了一个class，但是没有给具体的名字之前的统一名字，就像你在中国出生，你不知道叫什么名字，但是我可以喊你中国人。self是在为class编写instance method的时候，放在变量名的第一个位置的站位词。在具体的method中（class中的方法）可以不用self这个变量（def method（self）即可，在method里面都写self，方便后面出现了真的实例X后，可以直接调用）。 方法 init() 并未显式地包含 return 语句，但 Python 自动返回一个表示这条小狗的实例。我们将这个实例存储在变量 my_dog 中。给出实例后，后面需要调用方法，用实例.函数名（）即可。 12345class Dog():--snip-- my_dog = Dog(&#x27;willie&#x27;, 6)# my_dog就是实参 print(&quot;My dog&#x27;s name is &quot; + my_dog.name.title() + &quot;.&quot;) print(&quot;My dog is &quot; + str(my_dog.age) + &quot; years old.&quot;) 给属性和方法需要名字正常一点，方便能直接看出来方法是什么意思。 9.2给属性设定默认值（self.X=一个值）在self的时候这样给出，就相当于设定了默认值了。 9.3修改属性的值 方法一：直接访问实例，给他赋值：X=Y； 方法二：通过方法来修改：给出一个def方法，然后给这个方法中一个实参。 123456789class Car():--snip--def update_odometer(self, mileage):&quot;&quot;&quot; 将里程表读数设置为指定的值 &quot;&quot;&quot;self.odometer_reading = mileagemy_new_car = Car(&#x27;audi&#x27;, &#x27;a4&#x27;, 2016)print(my_new_car.get_descriptive_name()) my_new_car.update_odometer(23)my_new_car.read_odometer() 方法三：通过方法对属性的值进行递增（一种新的代码方法，不是直接赋值，而是用x+=Y）不停的给方法输入不同的y来达到递增的效果。 9.3 继承 编写类时，并非总是要从空白开始。如果你要编写的类是另一个现成类的特殊版本，可使用 继承 。一个类继承另一个类时，它将自动获得另一个类的所有属性和方法；原有的类称为父类而新类称为子类 。子类继承了其父类的所有属性和方法，同时还可以定义自己的属性和方法。 1234567891011121314151617181920212223242526class Car():&quot;&quot;&quot; 一次模拟汽车的简单尝试 &quot;&quot;&quot;def __init__(self, make, model, year):self.make = makeself.model = modelself.year = yearself.odometer_reading = 0def get_descriptive_name(self):long_name = str(self.year) + &#x27; &#x27; + self.make + &#x27; &#x27; + self.model return long_name.title()def read_odometer(self):print(&quot;This car has &quot; + str(self.odometer_reading) + &quot; miles on it.&quot;)def update_odometer(self, mileage):if mileage &gt;= self.odometer_reading:self.odometer_reading = mileageelse:print(&quot;You can&#x27;t roll back an odometer!&quot;)def increment_odometer(self, miles):self.odometer_reading += miles class ElectricCar(Car):&quot;&quot;&quot; 电动汽车的独特之处 &quot;&quot;&quot; def __init__(self, make, model, year):&quot;&quot;&quot; 初始化父类的属性 &quot;&quot;&quot; super().__init__(make, model, year)##这个函数很特殊，用init来调用父类的方法，注意，后面的参数不需要有self. my_tesla = ElectricCar(&#x27;tesla&#x27;, &#x27;model s&#x27;, 2016)print(my_tesla.get_descriptive_name()) 1.创建子类时，父类必须在子类的前面先创建好。 2.定义子类时，必须在括号内指定父类的名称。方法 init() 接受创建。 9.3.3 给子类定义属性和方法——创建完子类后，在里面定义新的就好。但是不用写在init里面，init里面是之前父类的。 1234567891011121314151617class Car():--snip--class ElectricCar(Car):&quot;&quot;&quot;Represent aspects of a car, specific to electric vehicles.&quot;&quot;&quot;def __init__(self, make, model, year):&quot;&quot;&quot;电动汽车的独特之处初始化父类的属性，再初始化电动汽车特有的属性&quot;&quot;&quot;super().__init__(make, model, year)❶ self.battery_size = 70❷ def describe_battery(self):#这里的self应该就是指新的electriccar的self吧&quot;&quot;&quot; 打印一条描述电瓶容量的消息 &quot;&quot;&quot;print(&quot;This car has a &quot; + str(self.battery_size) + &quot;-kWh battery.&quot;)my_tesla = ElectricCar(&#x27;tesla&#x27;, &#x27;model s&#x27;, 2016)print(my_tesla.get_descriptive_name())my_tesla.describe_battery( 9.3.4重写父类的方法：在子类中定义一个新的方法：方法名和父类要一样。 9.3.5将实例用作属性： 123456789101112131415161718192021class Car():--snip--❶ class Battery():&quot;&quot;&quot; 一次模拟电动汽车电瓶的简单尝试 &quot;&quot;&quot;❷ def __init__(self, battery_size=70):&quot;&quot;&quot; 初始化电瓶的属性 &quot;&quot;&quot;self.battery_size = battery_size❸ def describe_battery(self):&quot;&quot;&quot; 打印一条描述电瓶容量的消息 &quot;&quot;&quot;print(&quot;This car has a &quot; + str(self.battery_size) + &quot;-kWh battery.&quot;)class ElectricCar(Car):&quot;&quot;&quot; 电动汽车的独特之处 &quot;&quot;&quot;def __init__(self, make, model, year):&quot;&quot;&quot;初始化父类的属性，再初始化电动汽车特有的属性&quot;&quot;&quot;super().__init__(make, model, year)❹ self.battery = Battery()#NB！！这个特别关键，先创建一个electriccar属性self.battery，再将另一个类battery（）等于这个实例，从而electricacar类属性中就有了battery类了my_tesla = ElectricCar(&#x27;tesla&#x27;, &#x27;model s&#x27;, 2016print(my_tesla.get_descriptive_name())my_tesla.battery.describe_battery()#实参.类中类.类种类的方法 9.4 导入类 多了一句 from X（文件名）import（文件中的类）。很简单，不赘述。 本章学习：如何编写类；如何使用属性在类中存储信息，以及如何编写方法，以让类具备所需的行为；如何编写方法 init() ，以便根据类创建包含所需属性的实例。如何修改实例的属性 —— 包括直接修改以及通过方法进行修改。使用继承可简化相关类的创建工作；将一个类的实例用作另一个类的属性可让类更简洁。通过将类存储在模块中，并在需要使用这些类的文件中导入它们，可让项目组织有序。 至此，你掌握了编写组织有序而易于使用的程序所需的基本技能，该考虑让程序目标更明确、用途更大了。本文到此结束。","categories":[],"tags":[]},{"title":"ppython数据分析","slug":"python数据分析","date":"2021-03-12T11:55:22.000Z","updated":"2021-03-12T12:05:58.346Z","comments":true,"path":"2021/03/12/python数据分析/","link":"","permalink":"http://example.com/2021/03/12/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/","excerpt":"","text":"学习途径从code academy开始学起，完成上面的所有练习。每天投入3个小时，你应该在20天内完成它们。Code academy涵盖了Python基本概念。但是，它不像Udacity那样以项目为导向;没关系，因为你的目标是从事数据科学，而不是使用Python开发软件。 当完成了code academy练习之后，看看这个Ipython notebook: Python必备教程（在总结部分我已经提供了下载链接）。 它包括了code academy中没有提到的一些概念。你能在1到2小时内学完这个教程。 现在，你知道足够的基础知识来学习Python库了。 Numpy首先，开始学习Numpy吧，因为它是利用Python科学计算的基础包。对Numpy好的掌握将会帮助你有效地使用其他工具例如Pandas。 我已经准备好了IPython笔记，这包含了Numpy的一些基本概念。这个教程包含了Numpy中最频繁使用的操作，例如，N维数组，索引，数组切片，整数索引，数组转换，通用函数，使用数组处理数据，常用的统计方法，等等。 Numpy Basics Tutorial Index Numpy 遇到Numpy陌生函数，查询用法，推荐！ PandasPandas包含了高级的数据结构和操作工具，它们使得Python数据分析更加快速和容易。 教程包含了series, data frams，从一个axis删除数据，缺失数据处理，等等。 Pandas Basics Tutorial Index Pandas 遇到陌生函数，查询用法，推荐！ pandas教程-百度经验 Matplotlib这是一个分为四部分的Matplolib教程。 1st 部分:第一部分介绍了Matplotlib基本功能，基本figure类型。 Simple Plotting exampleIn [113]: 12345678%matplotlib inline import matplotlib.pyplot as plt #importing matplot lib libraryimport numpy as np x = range(100) #print x, print and check what is xy =[val**2 for val in x] #print yplt.plot(x,y) #plotting x and y Out[113]: 1[&lt;matplotlib.lines.Line2D at 0x7857bb0&gt;] 123456789fig, axes = plt.subplots(nrows=1, ncols=2)for ax in axes: ax.plot(x, y, &#x27;r&#x27;) ax.set_xlabel(&#x27;x&#x27;) ax.set_ylabel(&#x27;y&#x27;) ax.set_title(&#x27;title&#x27;) fig.tight_layout() 12345678fig, ax = plt.subplots()ax.plot(x, x**2, label=&quot;y = x**2&quot;)ax.plot(x, x**3, label=&quot;y = x**3&quot;)ax.legend(loc=2); # upper left cornerax.set_xlabel(&#x27;x&#x27;)ax.set_ylabel(&#x27;y&#x27;)ax.set_title(&#x27;title&#x27;); 12345678fig, axes = plt.subplots(1, 2, figsize=(10,4)) axes[0].plot(x, x**2, x, np.exp(x))axes[0].set_title(&quot;Normal scale&quot;)axes[1].plot(x, x**2, x, np.exp(x))axes[1].set_yscale(&quot;log&quot;)axes[1].set_title(&quot;Logarithmic scale (y)&quot;); 1n = np.array([0,1,2,3,4,5]) In [47]: 12345678910111213fig, axes = plt.subplots(1, 4, figsize=(12,3))axes[0].scatter(xx, xx + 0.25*np.random.randn(len(xx)))axes[0].set_title(&quot;scatter&quot;)axes[1].step(n, n**2, lw=2)axes[1].set_title(&quot;step&quot;)axes[2].bar(n, n**2, align=&quot;center&quot;, width=0.5, alpha=0.5)axes[2].set_title(&quot;bar&quot;)axes[3].fill_between(x, x**2, x**3, color=&quot;green&quot;, alpha=0.5);axes[3].set_title(&quot;fill_between&quot;); Using NumpyIn [17]: 123x = np.linspace(0, 2*np.pi, 100)y =np.sin(x)plt.plot(x,y) Out[17]: 1[&lt;matplotlib.lines.Line2D at 0x579aef0&gt;] In [24]: 123x= np.linspace(-3,2, 200)Y = x ** 2 - 2 * x + 1.plt.plot(x,Y) Out[24]: 1[&lt;matplotlib.lines.Line2D at 0x6ffb310&gt;] In [32]: 123456789# plotting multiple plotsx =np.linspace(0, 2 * np.pi, 100)y = np.sin(x)z = np.cos(x)plt.plot(x,y) plt.plot(x,z)plt.show()# Matplot lib picks different colors for different plot. In [35]: 1cd C:\\Users\\tk\\Desktop\\Matplot 1C:\\Users\\tk\\Desktop\\Matplot In [39]: 123456789data = np.loadtxt(&#x27;numpy.txt&#x27;)plt.plot(data[:,0], data[:,1]) # plotting column 1 vs column 2# The text in the numpy.txt should look like this# 0 0# 1 1# 2 4# 4 16# 5 25# 6 36 Out[39]: 1[&lt;matplotlib.lines.Line2D at 0x740f090&gt;] In [56]: 12345678910111213data1 = np.loadtxt(&#x27;scipy.txt&#x27;) # load the fileprint data1.Tfor val in data1.T: #loop over each and every value in data1.T plt.plot(data1[:,0], val) #data1[:,0] is the first row in data1.T # data in scipy.txt looks like this:# 0 0 6# 1 1 5# 2 4 4 # 4 16 3# 5 25 2# 6 36 1 123[[ 0. 1. 2. 4. 5. 6.] [ 0. 1. 4. 16. 25. 36.] [ 6. 5. 4. 3. 2. 1.]] Scatter Plots and Bar GraphsIn [64]: 123sct = np.random.rand(20, 2)print sctplt.scatter(sct[:,0], sct[:,1]) # I am plotting a scatter plot. 1234567891011121314151617181920[[ 0.51454542 0.61859101] [ 0.45115993 0.69774873] [ 0.29051205 0.28594808] [ 0.73240446 0.41905186] [ 0.23869394 0.5238878 ] [ 0.38422814 0.31108919] [ 0.52218967 0.56526379] [ 0.60760426 0.80247073] [ 0.37239096 0.51279078] [ 0.45864677 0.28952167] [ 0.8325996 0.28479446] [ 0.14609382 0.8275477 ] [ 0.86338279 0.87428696] [ 0.55481585 0.24481165] [ 0.99553336 0.79511137] [ 0.55025277 0.67267026] [ 0.39052024 0.65924857] [ 0.66868207 0.25186664] [ 0.64066313 0.74589812] [ 0.20587731 0.64977807]] Out[64]: 1&lt;matplotlib.collections.PathCollection at 0x78a7110&gt; In [65]: 123ghj =[5, 10 ,15, 20, 25]it =[ 1, 2, 3, 4, 5]plt.bar(ghj, it) # simple bar graph Out[65]: 1&lt;Container object of 5 artists&gt; In [74]: 123ghj =[5, 10 ,15, 20, 25]it =[ 1, 2, 3, 4, 5]plt.bar(ghj, it, width =5)# you can change the thickness of a bar, by default the bar will have a thickness of 0.8 units Out[74]: 1&lt;Container object of 5 artists&gt; In [75]: 123ghj =[5, 10 ,15, 20, 25]it =[ 1, 2, 3, 4, 5]plt.barh(ghj, it) # barh is a horizontal bar graph Out[75]: 1&lt;Container object of 5 artists&gt; Multiple bar charts In [95]: 1234567new_list = [[5., 25., 50., 20.], [4., 23., 51., 17.], [6., 22., 52., 19.]]x = np.arange(4) plt.bar(x + 0.00, new_list[0], color =&#x27;b&#x27;, width =0.25)plt.bar(x + 0.25, new_list[1], color =&#x27;r&#x27;, width =0.25)plt.bar(x + 0.50, new_list[2], color =&#x27;g&#x27;, width =0.25)#plt.show() In [100]: 123456#Stacked Bar chartsp = [5., 30., 45., 22.]q = [5., 25., 50., 20.]x =range(4)plt.bar(x, p, color =&#x27;b&#x27;)plt.bar(x, q, color =&#x27;y&#x27;, bottom =p) Out[100]: 1&lt;Container object of 4 artists&gt; In [35]: 123456789# plotting more than 2 valuesA = np.array([5., 30., 45., 22.])B = np.array([5., 25., 50., 20.])C = np.array([1., 2., 1., 1.])X = np.arange(4)plt.bar(X, A, color = &#x27;b&#x27;)plt.bar(X, B, color = &#x27;g&#x27;, bottom = A)plt.bar(X, C, color = &#x27;r&#x27;, bottom = A + B) # for the third argument, I use A+Bplt.show() In [94]: 12345black_money = np.array([5., 30., 45., 22.]) white_money = np.array([5., 25., 50., 20.])z = np.arange(4)plt.barh(z, black_money, color =&#x27;g&#x27;)plt.barh(z, -white_money, color =&#x27;r&#x27;)# - notation is needed for generating, back to back charts Out[94]: 1&lt;Container object of 4 artists&gt; Other PlotsIn [114]: 123#Pie chartsy = [5, 25, 45, 65]plt.pie(y) Out[114]: 12345678([&lt;matplotlib.patches.Wedge at 0x7a19d50&gt;, &lt;matplotlib.patches.Wedge at 0x7a252b0&gt;, &lt;matplotlib.patches.Wedge at 0x7a257b0&gt;, &lt;matplotlib.patches.Wedge at 0x7a25cb0&gt;], [&lt;matplotlib.text.Text at 0x7a25070&gt;, &lt;matplotlib.text.Text at 0x7a25550&gt;, &lt;matplotlib.text.Text at 0x7a25a50&gt;, &lt;matplotlib.text.Text at 0x7a25f50&gt;]) In [115]: 123#Histogramsd = np.random.randn(100)plt.hist(d, bins = 20) Out[115]: 12345678(array([ 2., 3., 2., 1., 2., 6., 5., 7., 10., 12., 9., 12., 11., 5., 6., 4., 1., 0., 1., 1.]), array([-2.9389701 , -2.64475645, -2.35054281, -2.05632916, -1.76211551, -1.46790186, -1.17368821, -0.87947456, -0.58526092, -0.29104727, 0.00316638, 0.29738003, 0.59159368, 0.88580733, 1.18002097, 1.47423462, 1.76844827, 2.06266192, 2.35687557, 2.65108921, 2.94530286]), &lt;a list of 20 Patch objects&gt;) In [116]: 12345d = np.random.randn(100)plt.boxplot(d)#1) The red bar is the median of the distribution#2) The blue box includes 50 percent of the data from the lower quartile to the upper quartile. # Thus, the box is centered on the median of the data. Out[116]: 12345678&#123;&#x27;boxes&#x27;: [&lt;matplotlib.lines.Line2D at 0x7cca090&gt;], &#x27;caps&#x27;: [&lt;matplotlib.lines.Line2D at 0x7c02d70&gt;, &lt;matplotlib.lines.Line2D at 0x7cc2c90&gt;], &#x27;fliers&#x27;: [&lt;matplotlib.lines.Line2D at 0x7cca850&gt;, &lt;matplotlib.lines.Line2D at 0x7ccae10&gt;], &#x27;medians&#x27;: [&lt;matplotlib.lines.Line2D at 0x7cca470&gt;], &#x27;whiskers&#x27;: [&lt;matplotlib.lines.Line2D at 0x7c02730&gt;, &lt;matplotlib.lines.Line2D at 0x7cc24b0&gt;]&#125; In [118]: 12d = np.random.randn(100, 5) # generating multiple box plotsplt.boxplot(d) Out[118]: 12345678910111213141516171819202122232425262728293031323334353637383940&#123;&#x27;boxes&#x27;: [&lt;matplotlib.lines.Line2D at 0x7f49d70&gt;, &lt;matplotlib.lines.Line2D at 0x7ea1c90&gt;, &lt;matplotlib.lines.Line2D at 0x7eafb90&gt;, &lt;matplotlib.lines.Line2D at 0x7ebea90&gt;, &lt;matplotlib.lines.Line2D at 0x7ece990&gt;], &#x27;caps&#x27;: [&lt;matplotlib.lines.Line2D at 0x7f2b3b0&gt;, &lt;matplotlib.lines.Line2D at 0x7f49990&gt;, &lt;matplotlib.lines.Line2D at 0x7ea14d0&gt;, &lt;matplotlib.lines.Line2D at 0x7ea18b0&gt;, &lt;matplotlib.lines.Line2D at 0x7eaf3d0&gt;, &lt;matplotlib.lines.Line2D at 0x7eaf7b0&gt;, &lt;matplotlib.lines.Line2D at 0x7ebe2d0&gt;, &lt;matplotlib.lines.Line2D at 0x7ebe6b0&gt;, &lt;matplotlib.lines.Line2D at 0x7ece1d0&gt;, &lt;matplotlib.lines.Line2D at 0x7ece5b0&gt;], &#x27;fliers&#x27;: [&lt;matplotlib.lines.Line2D at 0x7e98550&gt;, &lt;matplotlib.lines.Line2D at 0x7e98930&gt;, &lt;matplotlib.lines.Line2D at 0x7ea8470&gt;, &lt;matplotlib.lines.Line2D at 0x7ea8a10&gt;, &lt;matplotlib.lines.Line2D at 0x7eb6370&gt;, &lt;matplotlib.lines.Line2D at 0x7eb6730&gt;, &lt;matplotlib.lines.Line2D at 0x7ec6270&gt;, &lt;matplotlib.lines.Line2D at 0x7ec6810&gt;, &lt;matplotlib.lines.Line2D at 0x8030170&gt;, &lt;matplotlib.lines.Line2D at 0x8030710&gt;], &#x27;medians&#x27;: [&lt;matplotlib.lines.Line2D at 0x7e98170&gt;, &lt;matplotlib.lines.Line2D at 0x7ea8090&gt;, &lt;matplotlib.lines.Line2D at 0x7eaff70&gt;, &lt;matplotlib.lines.Line2D at 0x7ebee70&gt;, &lt;matplotlib.lines.Line2D at 0x7eced70&gt;], &#x27;whiskers&#x27;: [&lt;matplotlib.lines.Line2D at 0x7f2bb50&gt;, &lt;matplotlib.lines.Line2D at 0x7f491b0&gt;, &lt;matplotlib.lines.Line2D at 0x7e98cf0&gt;, &lt;matplotlib.lines.Line2D at 0x7ea10f0&gt;, &lt;matplotlib.lines.Line2D at 0x7ea8bf0&gt;, &lt;matplotlib.lines.Line2D at 0x7ea8fd0&gt;, &lt;matplotlib.lines.Line2D at 0x7eb6cd0&gt;, &lt;matplotlib.lines.Line2D at 0x7eb6ed0&gt;, &lt;matplotlib.lines.Line2D at 0x7ec6bd0&gt;, &lt;matplotlib.lines.Line2D at 0x7ec6dd0&gt;]&#125; MatplotLib Part 1 2nd 部分:包含了怎么调整figure的样式和颜色，例如：makers,line,thicness,line patterns和color map. 123%matplotlib inlineimport numpy as npimport matplotlib.pyplot as plt In [22]: 123456789p =np.random.standard_normal((50,2))p += np.array((-1,1)) # center the distribution at (-1,1)q =np.random.standard_normal((50,2))q += np.array((1,1)) #center the distribution at (-1,1)plt.scatter(p[:,0], p[:,1], color =&#x27;.25&#x27;)plt.scatter(q[:,0], q[:,1], color = &#x27;.75&#x27;) Out[22]: 1&lt;matplotlib.collections.PathCollection at 0x71dab90&gt; In [34]: 12dd =np.random.standard_normal((50,2))plt.scatter(dd[:,0], dd[:,1], color =&#x27;1.0&#x27;, edgecolor =&#x27;0.0&#x27;) # edge color controls the color of the edge Out[34]: 1&lt;matplotlib.collections.PathCollection at 0x7336670&gt; Custom Color for Bar charts,Pie charts and box plots:The below bar graph, plots x(1 to 50) (vs) y(50 random integers, within 0-100. But you need different colors for each value. For which we create a list containing four colors(color_set). The list comprehension creates 50 different color values from color_set In [9]: 1234vals = np.random.random_integers(99, size =50)color_set = [&#x27;.00&#x27;, &#x27;.25&#x27;, &#x27;.50&#x27;,&#x27;.75&#x27;]color_lists = [color_set[(len(color_set)* val) // 100] for val in vals]c = plt.bar(np.arange(50), vals, color = color_lists) In [8]: 123456hi =np.random.random_integers(8, size =10)color_set =[&#x27;.00&#x27;, &#x27;.25&#x27;, &#x27;.50&#x27;, &#x27;.75&#x27;]plt.pie(hi, colors = color_set)# colors attribute accepts a range of valuesplt.show()#If there are less colors than values, then pyplot.pie() will simply cycle through the color list. In the preceding #example, we gave a list of four colors to color a pie chart that consisted of eight values. Thus, each color will be used twice In [27]: 12345values = np.random.randn(100)w = plt.boxplot(values)for att, lines in w.iteritems(): for l in lines: l.set_color(&#x27;k&#x27;) Color Mapsknow more about hsv In [34]: 12345678910# how to color scatter plots#Colormaps are defined in the matplotib.cm module. This module provides #functions to create and use colormaps. It also provides an exhaustive choice of predefined color maps.import matplotlib.cm as cmN = 256angle = np.linspace(0, 8 * 2 * np.pi, N)radius = np.linspace(.5, 1., N)X = radius * np.cos(angle)Y = radius * np.sin(angle)plt.scatter(X,Y, c=angle, cmap = cm.hsv) Out[34]: 1&lt;matplotlib.collections.PathCollection at 0x714d9f0&gt; In [44]: 12345#Color in bar graphsimport matplotlib.cm as cmvals = np.random.random_integers(99, size =50)cmap = cm.ScalarMappable(col.Normalize(0,99), cm.binary)plt.bar(np.arange(len(vals)),vals, color =cmap.to_rgba(vals)) Out[44]: 1&lt;Container object of 50 artists&gt; Line StylesIn [4]: 12345678910111213# I am creating 3 levels of gray plots, with different line shades def pq(I, mu, sigma): a = 1. / (sigma * np.sqrt(2. * np.pi)) b = -1. / (2. * sigma ** 2) return a * np.exp(b * (I - mu) ** 2)I =np.linspace(-6,6, 1024)plt.plot(I, pq(I, 0., 1.), color = &#x27;k&#x27;, linestyle =&#x27;solid&#x27;)plt.plot(I, pq(I, 0., .5), color = &#x27;k&#x27;, linestyle =&#x27;dashed&#x27;)plt.plot(I, pq(I, 0., .25), color = &#x27;k&#x27;, linestyle =&#x27;dashdot&#x27;) Out[4]: 1[&lt;matplotlib.lines.Line2D at 0x562ffb0&gt;] In [12]: 1234567N = 15A = np.random.random(N)B= np.random.random(N)X = np.arange(N)plt.bar(X, A, color =&#x27;.75&#x27;)plt.bar(X, A+B , bottom = A, color =&#x27;W&#x27;, linestyle =&#x27;dashed&#x27;) # plot a bar graphplt.show() In [20]: 123456789101112def gf(X, mu, sigma): a = 1. / (sigma * np.sqrt(2. * np.pi)) b = -1. / (2. * sigma ** 2) return a * np.exp(b * (X - mu) ** 2)X = np.linspace(-6, 6, 1024)for i in range(64): samples = np.random.standard_normal(50) mu,sigma = np.mean(samples), np.std(samples) plt.plot(X, gf(X, mu, sigma), color = &#x27;.75&#x27;, linewidth = .5)plt.plot(X, gf(X, 0., 1.), color =&#x27;.00&#x27;, linewidth = 3.) Out[20]: 1[&lt;matplotlib.lines.Line2D at 0x59fbab0&gt;] Fill surfaces with patternIn [27]: 123456789101112131415161718N = 15A = np.random.random(N)B= np.random.random(N)X = np.arange(N)plt.bar(X, A, color =&#x27;w&#x27;, hatch =&#x27;x&#x27;)plt.bar(X, A+B,bottom =A, color =&#x27;r&#x27;, hatch =&#x27;/&#x27;)# some other hatch attributes are :#/#\\#|#-#+#x#o#O#.#* Out[27]: 1&lt;Container object of 15 artists&gt; Marker stylesIn [29]: 1cd C:\\Users\\tk\\Desktop\\Matplot 1C:\\Users\\tk\\Desktop\\Matplot Come back to this section laterIn [14]: 1234567X= np.linspace(-6,6,1024)Ya =np.sinc(X)Yb = np.sinc(X) +1plt.plot(X, Ya, marker =&#x27;o&#x27;, color =&#x27;.75&#x27;)plt.plot(X, Yb, marker =&#x27;^&#x27;, color=&#x27;.00&#x27;, markevery= 32)# this one marks every 32 nd element Out[14]: 1[&lt;matplotlib.lines.Line2D at 0x7063150&gt;] In [31]: 123456789# Marker SizeA = np.random.standard_normal((50,2))A += np.array((-1,1))B = np.random.standard_normal((50,2))B += np.array((1, 1))plt.scatter(A[:,0], A[:,1], color =&#x27;k&#x27;, s =25.0)plt.scatter(B[:,0], B[:,1], color =&#x27;g&#x27;, s = 100.0) # size of the marker is specified using &#x27;s&#x27; attribute Out[31]: 1&lt;matplotlib.collections.PathCollection at 0x7d015f0&gt; Own Marker Shapes- come back to this laterIn [65]: 1234# more about markersX =np.linspace(-6,6, 1024)Y =np.sinc(X)plt.plot(X,Y, color =&#x27;r&#x27;, marker =&#x27;o&#x27;, markersize =9, markevery = 30, markerfacecolor=&#x27;w&#x27;, linewidth = 3.0, markeredgecolor = &#x27;b&#x27;) Out[65]: 1[&lt;matplotlib.lines.Line2D at 0x84c9750&gt;] In [20]: 12345678910import matplotlib as mplmpl.rc(&#x27;lines&#x27;, linewidth =3)mpl.rc(&#x27;xtick&#x27;, color =&#x27;w&#x27;) # color of x axis numbersmpl.rc(&#x27;ytick&#x27;, color = &#x27;w&#x27;) # color of y axis numbersmpl.rc(&#x27;axes&#x27;, facecolor =&#x27;g&#x27;, edgecolor =&#x27;y&#x27;) # color of axes mpl.rc(&#x27;figure&#x27;, facecolor =&#x27;.00&#x27;,edgecolor =&#x27;w&#x27;) # color of figurempl.rc(&#x27;axes&#x27;, color_cycle = (&#x27;y&#x27;,&#x27;r&#x27;)) # color of plotsx = np.linspace(0, 7, 1024)plt.plot(x, np.sin(x))plt.plot(x, np.cos(x)) Out[20]: 1[&lt;matplotlib.lines.Line2D at 0x7b0fb70&gt;] MatplotLib Part2 3rd 部分:图的注释–包含若干图，控制坐标轴范围，长款比和坐标轴。 AnnotationIn [1]: 123%matplotlib inlineimport numpy as npimport matplotlib.pyplot as plt In [28]: 1234567X =np.linspace(-6,6, 1024)Y =np.sinc(X)plt.title(&#x27;A simple marker exercise&#x27;)# a title notationplt.xlabel(&#x27;array variables&#x27;) # adding xlabelplt.ylabel(&#x27; random variables&#x27;) # adding ylabelplt.text(-5, 0.4, &#x27;Matplotlib&#x27;) # -5 is the x value and 0.4 is y valueplt.plot(X,Y, color =&#x27;r&#x27;, marker =&#x27;o&#x27;, markersize =9, markevery = 30, markerfacecolor=&#x27;w&#x27;, linewidth = 3.0, markeredgecolor = &#x27;b&#x27;) Out[28]: 1[&lt;matplotlib.lines.Line2D at 0x84b6430&gt;] In [39]: 1234567891011121314151617181920212223def pq(I, mu, sigma): a = 1. / (sigma * np.sqrt(2. * np.pi)) b = -1. / (2. * sigma ** 2) return a * np.exp(b * (I - mu) ** 2)I =np.linspace(-6,6, 1024)plt.plot(I, pq(I, 0., 1.), color = &#x27;k&#x27;, linestyle =&#x27;solid&#x27;)plt.plot(I, pq(I, 0., .5), color = &#x27;k&#x27;, linestyle =&#x27;dashed&#x27;)plt.plot(I, pq(I, 0., .25), color = &#x27;k&#x27;, linestyle =&#x27;dashdot&#x27;)# I have created a dictinary of stylesdesign = &#123;&#x27;facecolor&#x27; : &#x27;y&#x27;, # color used for the text box&#x27;edgecolor&#x27; : &#x27;g&#x27;, &#x27;boxstyle&#x27; : &#x27;round&#x27; &#125;plt.text(-4, 1.5, &#x27;Matplot Lib&#x27;, bbox = design)plt.plot(X, Y, c=&#x27;k&#x27;)plt.show()#This sets the style of the box, which can either be &#x27;round&#x27; or &#x27;square&#x27;#&#x27;pad&#x27;: If &#x27;boxstyle&#x27; is set to &#x27;square&#x27;, it defines the amount of padding between the text and the box&#x27;s sides Alignment ControlThe text is bound by a box. This box is used to relatively align the text to the coordinates passed to pyplot.text(). Using the verticalalignment and horizontalalignment parameters (respective shortcut equivalents are va and ha), we can control how the alignment is done. The vertical alignment options are as follows:‘center’: This is relative to the center of the textbox‘top’: This is relative to the upper side of the textbox‘bottom’: This is relative to the lower side of the textbox‘baseline’: This is relative to the text’s baseline Horizontal alignment options are as follows: align =’bottom’ align =’baseline’————————align = center————————————–align= ‘top In [41]: 1cd C:\\Users\\tk\\Desktop 1C:\\Users\\tk\\Desktop In [44]: 123456from IPython.display import ImageImage(filename=&#x27;text alignment.png&#x27;)#The horizontal alignment options are as follows:#&#x27;center&#x27;: This is relative to the center of the textbox#&#x27;left&#x27;: This is relative to the left side of the textbox#&#x27;right&#x27;: This is relative to the right-hand side of the textbox Out[44]: In [76]: 12345678X = np.linspace(-4, 4, 1024)Y = .25 * (X + 4.) * (X + 1.) * (X - 2.)plt.annotate(&#x27;Big Data&#x27;, ha =&#x27;center&#x27;, va =&#x27;bottom&#x27;,xytext =(-1.5, 3.0), xy =(0.75, -2.7), arrowprops =&#123;&#x27;facecolor&#x27;: &#x27;green&#x27;, &#x27;shrink&#x27;:0.05, &#x27;edgecolor&#x27;: &#x27;black&#x27;&#125;) #arrow propertiesplt.plot(X, Y) Out[76]: 1[&lt;matplotlib.lines.Line2D at 0x9d1def0&gt;] In [74]: 1234#arrow styles are :from IPython.display import ImageImage(filename=&#x27;arrows.png&#x27;) Out[74]: Legend properties:‘loc’: This is the location of the legend. The default value is ‘best’, which will place it automatically. Other valid values are‘upper left’, ‘lower left’, ‘lower right’, ‘right’, ‘center left’, ‘center right’, ‘lower center’, ‘upper center’, and ‘center’. ‘shadow’: This can be either True or False, and it renders the legend with a shadow effect. ‘fancybox’: This can be either True or False and renders the legend with a rounded box. ‘title’: This renders the legend with the title passed as a parameter. ‘ncol’: This forces the passed value to be the number of columns for the legend In [101]: 12345678910x =np.linspace(0, 6,1024)y1 =np.sin(x)y2 =np.cos(x)plt.xlabel(&#x27;Sin Wave&#x27;)plt.ylabel(&#x27;Cos Wave&#x27;)plt.plot(x, y1, c=&#x27;b&#x27;, lw =3.0, label =&#x27;Sin(x)&#x27;) # labels are specifiedplt.plot(x, y2, c =&#x27;r&#x27;, lw =3.0, ls =&#x27;--&#x27;, label =&#x27;Cos(x)&#x27;)plt.legend(loc =&#x27;best&#x27;, shadow = True, fancybox = False, title =&#x27;Waves&#x27;, ncol =1) # displays the labelsplt.grid(True, lw = 2, ls =&#x27;--&#x27;, c=&#x27;.75&#x27;) # adds grid lines to the figureplt.show() ShapesIn [4]: 123456789101112131415161718192021#Paths for several kinds of shapes are available in the matplotlib.patches moduleimport matplotlib.patches as patchesdis = patches.Circle((0,0), radius = 1.0, color =&#x27;.75&#x27; )plt.gca().add_patch(dis) # used to render the image.dis = patches.Rectangle((2.5, -.5), 2.0, 1.0, color =&#x27;.75&#x27;) #patches.rectangle((x &amp; y coordinates), length, breadth)plt.gca().add_patch(dis)dis = patches.Ellipse((0, -2.0), 2.0, 1.0, angle =45, color =&#x27;.00&#x27;)plt.gca().add_patch(dis)dis = patches.FancyBboxPatch((2.5, -2.5), 2.0, 1.0, boxstyle =&#x27;roundtooth&#x27;, color =&#x27;g&#x27;)plt.gca().add_patch(dis)plt.grid(True)plt.axis(&#x27;scaled&#x27;) # displays the images within the prescribed axisplt.show()#FancyBox: This is like a rectangle but takes an additional boxstyle parameter #(either &#x27;larrow&#x27;, &#x27;rarrow&#x27;, &#x27;round&#x27;, &#x27;round4&#x27;, &#x27;roundtooth&#x27;, &#x27;sawtooth&#x27;, or &#x27;square&#x27;) In [22]: 12345678910import matplotlib.patches as patchestheta = np.linspace(0, 2 * np.pi, 8) # generates an arrayvertical = np.vstack((np.cos(theta), np.sin(theta))).transpose() # vertical stack clubs the two arrays. #print vertical, print and see how the array looksplt.gca().add_patch(patches.Polygon(vertical, color =&#x27;y&#x27;))plt.axis(&#x27;scaled&#x27;)plt.grid(True)plt.show()#The matplotlib.patches.Polygon()constructor takes a list of coordinates as the inputs, that is, the vertices of the polygon In [34]: 123456789# a polygon can be imbided into a circletheta = np.linspace(0, 2 * np.pi, 6) # generates an arrayvertical = np.vstack((np.cos(theta), np.sin(theta))).transpose() # vertical stack clubs the two arrays. #print vertical, print and see how the array looksplt.gca().add_patch(plt.Circle((0,0), radius =1.0, color =&#x27;b&#x27;))plt.gca().add_patch(plt.Polygon(vertical, fill =None, lw =4.0, ls =&#x27;dashed&#x27;, edgecolor =&#x27;w&#x27;))plt.axis(&#x27;scaled&#x27;)plt.grid(True)plt.show() Ticks in MatplotlibIn [54]: 12345678910#In matplotlib, ticks are small marks on both the axes of a figureimport matplotlib.ticker as tickerX = np.linspace(-12, 12, 1024)Y = .25 * (X + 4.) * (X + 1.) * (X - 2.)pl =plt.axes() #the object that manages the axes of a figurepl.xaxis.set_major_locator(ticker.MultipleLocator(5))pl.xaxis.set_minor_locator(ticker.MultipleLocator(1))plt.plot(X, Y, c = &#x27;y&#x27;)plt.grid(True, which =&#x27;major&#x27;) # which can take three values: minor, major and bothplt.show() In [59]: 12345678name_list = (&#x27;Omar&#x27;, &#x27;Serguey&#x27;, &#x27;Max&#x27;, &#x27;Zhou&#x27;, &#x27;Abidin&#x27;)value_list = np.random.randint(0, 99, size = len(name_list))pos_list = np.arange(len(name_list))ax = plt.axes()ax.xaxis.set_major_locator(ticker.FixedLocator((pos_list)))ax.xaxis.set_major_formatter(ticker.FixedFormatter((name_list)))plt.bar(pos_list, value_list, color = &#x27;.75&#x27;,align = &#x27;center&#x27;)plt.show() MatplotLib Part3 4th 部分:包含了一些复杂图形。 Working with figuresIn [4]: 123%matplotlib inlineimport numpy as npimport matplotlib.pyplot as plt In [5]: 12345T = np.linspace(-np.pi, np.pi, 1024) #fig, (ax0, ax1) = plt.subplots(ncols =2)ax0.plot(np.sin(2 * T), np.cos(0.5 * T), c = &#x27;k&#x27;)ax1.plot(np.cos(3 * T), np.sin(T), c = &#x27;k&#x27;)plt.show() Setting aspect ratioIn [7]: 1234T = np.linspace(0, 2 * np.pi, 1024)plt.plot(2. * np.cos(T), np.sin(T), c = &#x27;k&#x27;, lw = 3.)plt.axes().set_aspect(&#x27;equal&#x27;) # remove this line of code and see how the figure looksplt.show() In [12]: 123456X = np.linspace(-6, 6, 1024)Y1, Y2 = np.sinc(X), np.cos(X)plt.figure(figsize=(10.24, 2.56)) #sets size of the figureplt.plot(X, Y1, c=&#x27;r&#x27;, lw = 3.)plt.plot(X, Y2, c=&#x27;.75&#x27;, lw = 3.)plt.show() In [8]: 1234X = np.linspace(-6, 6, 1024)plt.ylim(-.5, 1.5)plt.plot(X, np.sinc(X), c = &#x27;k&#x27;)plt.show() In [16]: 12345678X = np.linspace(-6, 6, 1024)Y = np.sinc(X)X_sub = np.linspace(-3, 3, 1024)#coordinates of subplotY_sub = np.sinc(X_sub) # coordinates of sub plotplt.plot(X, Y, c = &#x27;b&#x27;) sub_axes = plt.axes([.6, .6, .25, .25])# coordinates, length and width of the subplot framesub_axes.plot(X_detail, Y_detail, c = &#x27;r&#x27;)plt.show() Log ScaleIn [20]: 123456789X = np.linspace(1, 10, 1024)plt.yscale(&#x27;log&#x27;) # set y scale as log. we would use plot.xscale()plt.plot(X, X, c = &#x27;k&#x27;, lw = 2., label = r&#x27;$f(x)=x$&#x27;)plt.plot(X, 10 ** X, c = &#x27;.75&#x27;, ls = &#x27;--&#x27;, lw = 2., label = r&#x27;$f(x)=e^x$&#x27;)plt.plot(X, np.log(X), c = &#x27;.75&#x27;, lw = 2., label = r&#x27;$f(x)=\\log(x)$&#x27;)plt.legend()plt.show()#The logarithm base is 10 by default, but it can be changed with the optional parameters basex and basey. Polar CoordinatesIn [23]: 1234T = np.linspace(0 , 2 * np.pi, 1024)plt.axes(polar = True) # show polar coordinatesplt.plot(T, 1. + .25 * np.sin(16 * T), c= &#x27;k&#x27;)plt.show() In [25]: 1234567import matplotlib.patches as patches # import patch module from matplotlibax = plt.axes(polar = True)theta = np.linspace(0, 2 * np.pi, 8, endpoint = False)radius = .25 + .75 * np.random.random(size = len(theta))points = np.vstack((theta, radius)).transpose()plt.gca().add_patch(patches.Polygon(points, color = &#x27;.75&#x27;))plt.show() In [2]: 12345x = np.linspace(-6,6,1024)y= np.sin(x)plt.plot(x,y)plt.savefig(&#x27;bigdata.png&#x27;, c= &#x27;y&#x27;, transparent = True) #savefig function writes that data to a file# will create a file named bigdata.png. Its resolution will be 800 x 600 pixels, in 8-bit colors (24-bits per pixel) In [3]: 12345678theta =np.linspace(0, 2 *np.pi, 8)points =np.vstack((np.cos(theta), np.sin(theta))).Tplt.figure(figsize =(6.0, 6.0))plt.gca().add_patch(plt.Polygon(points, color =&#x27;r&#x27;))plt.axis(&#x27;scaled&#x27;)plt.grid(True)plt.savefig(&#x27;pl.png&#x27;, dpi =300) # try &#x27;pl.pdf&#x27;, pl.svg&#x27;#dpi is dots per inch. 300*8 x 6*300 = 2400 x 1800 pixels MatplotLib Part4 总结你学习Python时能犯的最简单的错误之一就是同时去尝试学习过多的库。当你努力一下子学会每样东西时，你会花费很多时间来切换这些不同概念之间，变得沮丧，最后转移到其他事情上。 所以，坚持关注这个过程： 理解Python基础 学习Numpy 学习Pandas 学习Matplolib","categories":[],"tags":[]},{"title":"数据分析入门","slug":"数据分析入门","date":"2021-03-12T11:49:08.000Z","updated":"2021-03-12T12:05:58.338Z","comments":true,"path":"2021/03/12/数据分析入门/","link":"","permalink":"http://example.com/2021/03/12/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/","excerpt":"","text":"step0说起学习计划，先说说学习目标，数据挖掘是干什么的？我的理解啊，加上之前看的一些知乎 工作领域介绍目前国内的数据挖掘人员工作领域大致可分为三类。 数据分析师：在拥有行业数据的电商、金融、电信、咨询等行业里做业务咨询，商务智能，出分析报告。 数据挖掘工程师：在多媒体、电商、搜索、社交等大数据相关行业里做机器学习算法实现和分析。 科学研究方向：在高校、科研单位、企业研究院等高大上科研机构研究新算法效率改进及未来应用。 我觉得吧最可能做的事是前两者，更大概率是数据分析师。 这个是网上给出的要求 所需技能介绍说说各工作领域需要掌握的技能。 数据分析师 需要有深厚的数理统计基础，但是对程序开发能力不做要求。 需要熟练使用主流的数据挖掘（或统计分析）工具如Business Analytics and Business Intelligence Software（SAS）、SPSS、EXCEL等。需要对与所在行业有关的一切核心数据有深入的理解，以及一定的数据敏感性培养。 经典图书推荐：《概率论与数理统计》、《统计学》推荐David Freedman版、《业务建模与数据挖掘》、《数据挖掘导论》、《SAS编程与数据挖掘商业案例》、《Clementine数据挖掘方法及应用 》、《Excel 2007 VBA参考大全》、《IBM SPSS Statistics 19 Statistical Procedures Companion》等。 数据挖掘工程师 需要理解主流机器学习算法的原理和应用。 需要熟悉至少一门编程语言如（Python、C、C++、Java、Delphi等）。需要理解数据库原理，能够熟练操作至少一种数据库（Mysql、SQL、DB2、Oracle等），能够明白MapReduce的原理操作以及熟练使用Hadoop系列工具更好。 经典图书推荐：《数据挖掘概念与技术》、《机器学习实战》、《人工智能及其应用》、《数据库系统概论》、《算法导论》、《Web数据挖掘》、《 Python标准库》、《thinking in Java》、《Thinking in C++》、《数据结构》等。 这些呢，是大概对这个职业的介绍，也是我目前了解到的。 step1数据分析的第一步当然是分析语言啦，作为正统科班出身的程序员来说，掌握一门新的统计语言肯定是小case。 在我的了解中，数据分析中常用的有Python，以及R语言。这两种语言都有丰富的第三方库，当然个人更推荐用Python一些。如果可能还是学习Python3吧，主流的统计库都有了Python3的版本，推荐下载各种库的集成版本Anaconda Python，这个发行版集成了数据分析，数据挖掘，机器学习中会用到的一些第三方库，特别方便。 step2数据分析需要看，或者了解一些知识，很大程度上与机器学习有关，我推荐我看过的两本书： 第一本 机器学习 国内特有名的一本机器学习入门书籍，基础介绍了机器学习中用到的各种方法（当然不是很深入，但是入门已经够了）。 第二本 数据挖掘:概念与技术 也是特棒的一本书 我看网上还有别的推荐 利用Python进行数据分析(亚马逊) 包括各种案例 SciPy and NumPy (豆瓣) 数据分析中最常用的两个库 Python for Data Analysis作者是Pandas这个包的作者，一个大牛写的书 step3对整体有一个大概的概念后，可以去网上找些公开课，这些网易云课堂上有挺多的，以及Coursera上也有很多的,这些上面都有免费的优质课程资源。 step4在看公开课的同时，可以找一些项目进行练手，这些在知乎的Python中文社区中可以找到大量丰富的资源，可以关注下这个社区。 step5感觉自己学有所成，小宇宙爆发后，可以去打些比赛，关于数据挖掘，数据分析方面的。 国内有名的比赛平台就是阿里天池，以及国际上最出名的平台Kaggle,这两个平台上都有各种比赛项目，主要是有各路大神分享经验，对自己提高挺好的。 step6哈哈哈哈哈哈,我也是一个萌萌的新人，可能知道的不全，一起在学习中成长呗。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-03-12T10:44:35.786Z","updated":"2021-03-12T12:05:58.335Z","comments":true,"path":"2021/03/12/hello-world/","link":"","permalink":"http://example.com/2021/03/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"搭建hexo踩过的坑","slug":"搭建hexo踩过的坑","date":"2021-03-11T16:00:00.000Z","updated":"2021-03-13T03:27:09.272Z","comments":true,"path":"2021/03/12/搭建hexo踩过的坑/","link":"","permalink":"http://example.com/2021/03/12/%E6%90%AD%E5%BB%BAhexo%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/","excerpt":"","text":"你是否想拥有属于自己的博客？你是否无奈与自己不会写网站而烦恼？ 不要担心，本系列教程将会实现你白嫖的愿望，连服务器都不需要买，就算没有任何编程基础也可以学会的搭建博客教程 下面来看看这些好看的个人博客： http://fech.in/ https://xaoxuu.com/ https://nexmoe.com/ https://sakura.hojun.cn/ 以上的博客你是否都心动了呢？我想说的是，它们都是由hexo搭建的，等你学完了基础和进阶篇，上面展示的博客你都可以实现，就让我们一步步来吧！ 这是一个系列教程，有基础篇和进阶篇，让我们看看这两个教程实现的效果 【基础篇】 学会安装相应需要的依赖软件 学会更换主题 学会基本的站点配置 知道怎么生成文章并编辑 上传你的博客并拥有一个可以访问的地址 进阶篇 学会用markdown基本语法编写你的文章 学会如何搭建一个免费的图床并使用 学会进一步配置主题并了解所有主题的基本功能 拥有自己的域名并绑定 使用一些插件让自己博客更完美 备份 3\\|0**搭建之前的准备**3\\|1**安装nodejs** 下载地址： http://nodejs.cn/download/ 选择windows安装包.msi安装 运行安装包，我们默认选择c盘 在这里选择Add to PATH然后点Next继续就行了 3\\|2**安装Git** 下载地址：https://git-scm.com/ 点这里即可下载最新版本，如果你的下载速度比较慢可以选择下面的链接下载 https://www.lanzous.com/i9s7tib 运行安装包，选择合适的安装位置，然后点Next 后面的安装步骤全部只要点Next就行了，不需要我们多余配置 3\\|3**验证nodejs是否安装配置成功** 我们安装完Git后，在桌面右键会有Git Bash Here，我们直接点开 会出来一个终端，我们分别执行下面的命令 12$ node -v$ npm -v 如果输出了版本号，那么证明配置成功，如果没有版本号，请重新安装nodejs（检查是否勾选Add to Path），或者手动为nodejs添加环境变量 3\\|4**安装cnpm** 在git bash里面执行下面的命令 1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 检查cnpm是否安装成功 执行 1$ cnpm -v 如果输出版本号就是安装成功了 4\\|0**安装hexo和初始化博客**4\\|1**安装hexo** 在git bash执行下面的命令安装hexo 1$ cnpm install hexo-cli -g 4\\|2**初始化博客** 选择一个文件夹，然后右键打开git bash 例如：我在F盘新建了一个blog文件夹，就在blog文件夹下打开git bash 然后这里会显示你当前目录 然后执行 1$ hexo init 到Install dependencies的时候你可能会卡住，这是大多数人基本都会遇到的 我们只需要在这里的时候结束命令，按Ctrl + c就可以结束命令 然后执行下面这个命令，就可以使用国内的镜像为你完成博客的初始化工作 1$ cnpm install 其他方法： git clone https://e.coding.net/huanhao/hexoblog.git cnpm install 然后继续下面的步骤 等待命令完成后，就完成了初始化，现在就可以预览我们的博客了 执行下面这个命令 1注意：请不要结束命令或者关闭终端 1$ hexo s 然后会出来一段http开头的网址，我们复制下来然后在浏览器打开 就会出现这么一个页面了 5\\|0**更换主题** 你是否觉得上面的默认主题有点不好看呢？现在教你如何替换主题 hexo的所有主题都在下面这个地址： https://hexo.io/themes/ 你可能会在这个地址看到很多好看的主题，但是我们要慢慢来，有些主题的配置难度还是很高的 我们要找一个功能齐全，配置简单的主题练练手 就是这个新手入门hexo必备的Next主题 预览效果：https://theme-next.org/ 项目地址：https://github.com/theme-next/hexo-theme-next 配置文档：https://theme-next.org/docs/getting-started/ 如你所见，其实每个主题都会包含这个三个东西 预览效果 项目地址 配置文档 点击主题的图片可以打开预览地址，点击主题的标题可以打开项目地址 配置文档我们需要自己去项目地址找，大多数主题的项目地址都是英文，大家可以开翻译找一下 5\\|1**如何下载主题** 方法1打开主题的项目地址后，点击Clone or download 然后复制https开头的地址 然后在你的博客文件夹下面打开git bash 执行： 1git clone 复制的地址 themes/主题名字 如图： 现在给你解释一下这个命令 git clone 代表克隆，后面接上一串下载地址，最后面的themes/next是把文件夹下载到主题目录下，并把主题文件命名为next 方法2如果你觉得比较麻烦，还有第二个办法 打开主题项目地址，然后点击Clone or download，然后点击Download ZIP 这样可以下载主题文件压缩包，前提是你已经登入了github（没有账号的，请自己注册一下） 然后解压压缩包，把文件夹放在博客目录下的themes目录，并把文件夹命名为主题的名字 5\\|2**修改配置文件** 在博客的目录下有一个叫_config.yml的文件 将它打开 找到themes这一行，然后将主题名字修改为next 这样的话，主题就成功更换了 5\\|3**预览主题** 在博客目录打开git bash 执行 1hexo s 还是会出现一段浏览地址，我们在浏览器打开就行了 注意：有些主题你更换之后是暂时无法预览的，因为有的主题还需要安装它需要的依赖，这一般都会在主题的文档里面提到，只有安装它的依赖之后才可以正常预览，这里暂时不做说明，会在hexo教程进阶篇说到 6\\|0**配置主题** 这里不会做详细的配置介绍，在进阶篇会完整说明 我们需要认识两个文件 站点配置文件 指的是博客根目录下的_config.yml 主题配置文件 指的是某个主题下的_config.yml 它们的名字都叫_config.yml但是你不能弄混淆 在我们看主题文档配置的时候，是必须要分清这两个概念的，不然会报错 我们先来几个基本的配置 6\\|1**设置语言** 在Next主题的文档里面提到了如何更换语言 它要求我们更改的是站点配置文件，并且给出了代码示范 我们打开站点配置文件 按照要求，将language的配置改成zh-CN，然后保存文件 6\\|2**其他设置** 现在再来尝试一个 Next主题里面有个Scheme选项，可以更改主题的外观 根据要求，我们需要更改的是主题配置文件 打开主题配置文件，我们尝试scheme改成双栏，也就是需要修改成Pisces 现在已经修改过两个配置了，为了检验是否修改成功，我们需要预览一下主题 在博客根目录下执行 1hexo s 然后打开链接 可以看到都设置成功了 因为这个主题的主题文档是英文的，所以可能配置起来不太方便，我这里有一个中文的 是别人翻译的，不过现在不是最新版本的翻译 http://theme-next.iissnan.com/ 如果你有能力，可以自己挑一个主题进行简单配置，在进阶篇中会使用其他主题为你展示更详细的配置教程 7\\|0**生成文章的编辑工具** 在博客根目录下面执行： 1$ hexo new &quot;文章链接&quot; 例如：你想创建一个名为”我的第一个博客“的文章 可以执行： 1$ hexo new &quot;my-first-blog&quot; 文章链接建议是英文，然后会显示你的文章生成的目录，每次生成的文章都固定在你的博客根目录下面的source/_posts下 可以看到是一个后缀为.md的文件，这个其实是一个markdown文件，如果你不知道markdown是什么，在进阶篇会告诉你，就算你不会markdown，你可以暂时把这个当成txt文件 我建议你安装Typora编辑.md文件 https://www.typora.io/ 按照目录打开my-firsy-blog.md文件，可以看到一个横线上面有一段信息 这里面是存放你博客信息的地方 title 文章标题 date 文章日期 tag 文章标签 （暂时不说明如何配置，进阶篇会讲到） 然后这时候你可以修改文章标题，并且在横线下面输入你文章的内容 保存之后，你可以在博客根目录打开git bash 执行 1$ hexo s 记得：预览博客都是这个命令 8\\|0**部署你的博客** 现在我们的博客都是只能本地预览，如何将我们的上传到一个地方，然后通过域名访问呢？ 你可能觉得需要一个服务器再买个域名绑定，我可以告诉你都不需要 github部署 创建一个仓库 仓库名必须是用户名 + .github.io 然后勾选初始化README 我们暂时不能直接上传，需要进行一些配置，如下： 接下来需要我们创建一个git秘钥 打开git bash（不要求在哪个目录） 执行： “这里面是你的邮箱” 不管出现什么信息，你只需要回车就可以了 1$ ssh-keygen -t rsa -C “your_email@youremail.com“ 然后执行 1$ cat ~/.ssh/id_rsa.pub 会输出你的秘钥，我们复制输出信息就行了 然后点击头像，点击Settings–SSH·····–New SSH Key 粘贴你复制的秘钥 然后打开git bash 执行： 1$ ssh -T git@github.com 会提示你下面这个，输入yes回车就行了 1Are you sure you want to continue connecting (yes/no/[fingerprint])? 打开项目，点击绿色按钮，点击Use SSH 复制git开头的地址 打开站点配置文件 修改deploy信息 1234deploy: type: git repo: 你复制的地址 branch: master 例如： 在博客根目录下打开git bash 分别执行下面的命令： yourname是你的名字 youremail是你的邮箱 12$ git config --global user.name &quot;yourname&quot;$ git config --global user.email &quot;youremail&quot; 然后安装上传插件 1cnpm install hexo-deployer-git --save 上传 以上的配置完成之后，就可以上传了 在博客根目录下打开git bash，执行下面的命令就可以上传了 1hexo g -d 然后打开项目，点击Settings 往下滑找到Github pages 点击none 选择master branch 之后你会得到一个地址，这个就是你的网站地址了","categories":[],"tags":[]}],"categories":[],"tags":[]}